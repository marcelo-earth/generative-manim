{"prompt": "Create a blue circle that grows from the center of the screen", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        circle = Circle(color=BLUE, fill_opacity=0.5)\n        self.play(GrowFromCenter(circle))\n        self.wait()"}
{"prompt": "Show the text 'Machine Learning' appearing letter by letter", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        text = Text('Machine Learning', font_size=72)\n        self.play(Write(text))\n        self.wait()"}
{"prompt": "Create a red square that rotates 360 degrees", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        square = Square(color=RED, fill_opacity=0.7)\n        self.play(Create(square))\n        self.play(Rotate(square, angle=2*PI), run_time=2)\n        self.wait()"}
{"prompt": "Show a circle transforming into a triangle", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        circle = Circle(color=BLUE)\n        triangle = Triangle(color=GREEN)\n        self.play(Create(circle))\n        self.play(ReplacementTransform(circle, triangle))\n        self.wait()"}
{"prompt": "Display the Pythagorean theorem formula", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        formula = MathTex('a^2 + b^2 = c^2', font_size=96)\n        self.play(Write(formula))\n        self.wait()"}
{"prompt": "Create three circles in a row, colored red green and blue", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        c1 = Circle(color=RED, fill_opacity=0.8).shift(LEFT*2.5)\n        c2 = Circle(color=GREEN, fill_opacity=0.8)\n        c3 = Circle(color=BLUE, fill_opacity=0.8).shift(RIGHT*2.5)\n        self.play(Create(c1), Create(c2), Create(c3))\n        self.wait()"}
{"prompt": "Animate a dot moving along a circle path", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        circle = Circle(radius=2, color=WHITE)\n        dot = Dot(color=YELLOW).move_to(circle.point_from_proportion(0))\n        self.add(circle)\n        self.play(MoveAlongPath(dot, circle), run_time=3)\n        self.wait()"}
{"prompt": "Show a bar chart with values 3, 7, 5, 9, 2", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        chart = BarChart(\n            values=[3, 7, 5, 9, 2],\n            bar_names=['A', 'B', 'C', 'D', 'E'],\n            bar_colors=[BLUE, GREEN, YELLOW, RED, PURPLE]\n        )\n        self.play(Create(chart))\n        self.wait()"}
{"prompt": "Create a number line from -5 to 5 with a dot that moves from -3 to 3", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        number_line = NumberLine(x_range=[-5, 5, 1], include_numbers=True)\n        dot = Dot(color=RED).move_to(number_line.n2p(-3))\n        self.play(Create(number_line))\n        self.play(Create(dot))\n        self.play(dot.animate.move_to(number_line.n2p(3)), run_time=2)\n        self.wait()"}
{"prompt": "Draw a sine wave on a coordinate plane", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        axes = Axes(x_range=[-4, 4, 1], y_range=[-2, 2, 1], axis_config={'include_numbers': True})\n        sine_curve = axes.plot(lambda x: np.sin(x), color=BLUE)\n        label = axes.get_graph_label(sine_curve, label='\\\\sin(x)')\n        self.play(Create(axes))\n        self.play(Create(sine_curve), Write(label))\n        self.wait()"}
{"prompt": "Show a square morphing into a circle with smooth animation", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        square = Square(side_length=2, color=YELLOW, fill_opacity=0.5)\n        circle = Circle(radius=1, color=PURPLE, fill_opacity=0.5)\n        self.play(Create(square))\n        self.play(Transform(square, circle), run_time=2)\n        self.wait()"}
{"prompt": "Create an arrow pointing from left to right with a label", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        arrow = Arrow(LEFT*3, RIGHT*3, color=WHITE)\n        label = Text('Direction', font_size=36).next_to(arrow, UP)\n        self.play(GrowArrow(arrow))\n        self.play(Write(label))\n        self.wait()"}
{"prompt": "Display a 2x2 matrix with animation", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        matrix = Matrix([[1, 2], [3, 4]])\n        self.play(Write(matrix))\n        self.wait()"}
{"prompt": "Show text fading in then fading out", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        text = Text('Hello World', font_size=72, color=WHITE)\n        self.play(FadeIn(text, shift=UP))\n        self.wait(0.5)\n        self.play(FadeOut(text, shift=DOWN))\n        self.wait()"}
{"prompt": "Create a group of 5 dots arranged in a pentagon shape", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        pentagon = RegularPolygon(n=5, radius=2)\n        dots = VGroup(*[Dot(color=YELLOW, radius=0.15).move_to(pentagon.point_from_proportion(i/5)) for i in range(5)])\n        self.play(Create(dots))\n        self.wait()"}
{"prompt": "Animate a counter counting from 0 to 10", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        number = DecimalNumber(0, num_decimal_places=0, font_size=96)\n        self.add(number)\n        self.play(ChangeDecimalToValue(number, 10), run_time=3)\n        self.wait()"}
{"prompt": "Create a gradient background going from blue to purple with a white title", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        bg = Rectangle(width=14, height=8, fill_opacity=1)\n        bg.set_color(color=[BLUE, PURPLE])\n        title = Text('Generative Manim', font_size=72, color=WHITE)\n        self.add(bg)\n        self.play(Write(title))\n        self.wait()"}
{"prompt": "Show two vectors being added together visually", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        plane = NumberPlane()\n        v1 = Arrow(ORIGIN, [2, 1, 0], color=RED, buff=0)\n        v2 = Arrow([2, 1, 0], [3, 3, 0], color=BLUE, buff=0)\n        v_sum = Arrow(ORIGIN, [3, 3, 0], color=GREEN, buff=0)\n        l1 = MathTex('\\\\vec{a}', color=RED).next_to(v1, DOWN)\n        l2 = MathTex('\\\\vec{b}', color=BLUE).next_to(v2, RIGHT)\n        l3 = MathTex('\\\\vec{a}+\\\\vec{b}', color=GREEN).next_to(v_sum, LEFT)\n        self.add(plane)\n        self.play(GrowArrow(v1), Write(l1))\n        self.play(GrowArrow(v2), Write(l2))\n        self.play(GrowArrow(v_sum), Write(l3))\n        self.wait()"}
{"prompt": "Create a pie chart showing 40% blue, 30% red, 30% green", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        sectors = VGroup()\n        colors = [BLUE, RED, GREEN]\n        percentages = [0.4, 0.3, 0.3]\n        labels = ['40%', '30%', '30%']\n        start = 0\n        for pct, color, label_text in zip(percentages, colors, labels):\n            sector = Sector(outer_radius=2, angle=pct*TAU, start_angle=start, color=color, fill_opacity=0.8)\n            mid_angle = start + pct*TAU/2\n            label = Text(label_text, font_size=24, color=WHITE).move_to(1.3*np.array([np.cos(mid_angle), np.sin(mid_angle), 0]))\n            sectors.add(sector, label)\n            start += pct*TAU\n        self.play(Create(sectors), run_time=2)\n        self.wait()"}
{"prompt": "Draw a right triangle and label the sides a, b, c", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        A = ORIGIN\n        B = RIGHT*3\n        C = UP*2\n        triangle = Polygon(A, B, C, color=WHITE)\n        right_angle = RightAngle(Line(A, B), Line(A, C), length=0.3)\n        a_label = MathTex('a').next_to(Line(A, B), DOWN)\n        b_label = MathTex('b').next_to(Line(A, C), LEFT)\n        c_label = MathTex('c').next_to(Line(B, C), RIGHT)\n        self.play(Create(triangle), Create(right_angle))\n        self.play(Write(a_label), Write(b_label), Write(c_label))\n        self.wait()"}
{"prompt": "Show a 3D rotating cube", "code": "from manim import *\n\nclass GenScene(ThreeDScene):\n    def construct(self):\n        cube = Cube(side_length=2, fill_opacity=0.7, fill_color=BLUE)\n        self.set_camera_orientation(phi=75*DEGREES, theta=30*DEGREES)\n        self.play(Create(cube))\n        self.begin_ambient_camera_rotation(rate=0.5)\n        self.wait(4)\n        self.stop_ambient_camera_rotation()"}
{"prompt": "Create an animation showing bubble sort on 5 bars", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        values = [4, 2, 5, 1, 3]\n        bars = VGroup()\n        for i, v in enumerate(values):\n            bar = Rectangle(width=0.8, height=v*0.6, fill_opacity=0.8, fill_color=BLUE, color=WHITE)\n            bar.move_to(RIGHT*(i*1.2 - 2.4) + UP*v*0.3)\n            bars.add(bar)\n        self.play(Create(bars))\n        for i in range(len(values)):\n            for j in range(len(values)-1-i):\n                bars[j].set_color(YELLOW)\n                bars[j+1].set_color(YELLOW)\n                self.wait(0.3)\n                if values[j] > values[j+1]:\n                    values[j], values[j+1] = values[j+1], values[j]\n                    self.play(bars[j].animate.shift(RIGHT*1.2), bars[j+1].animate.shift(LEFT*1.2), run_time=0.5)\n                    bars[j], bars[j+1] = bars[j+1], bars[j]\n                bars[j].set_color(BLUE)\n                bars[j+1].set_color(BLUE)\n        bars.set_color(GREEN)\n        self.wait()"}
{"prompt": "Display Euler's identity with each part colored differently", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        euler = MathTex('e', '^{i\\\\pi}', '+', '1', '=', '0', font_size=96)\n        euler[0].set_color(RED)\n        euler[1].set_color(BLUE)\n        euler[2].set_color(WHITE)\n        euler[3].set_color(GREEN)\n        euler[4].set_color(WHITE)\n        euler[5].set_color(YELLOW)\n        self.play(Write(euler), run_time=3)\n        self.wait()"}
{"prompt": "Create a wave animation using sine function that moves across the screen", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        axes = Axes(x_range=[0, 10, 1], y_range=[-2, 2, 1])\n        t = ValueTracker(0)\n        curve = always_redraw(lambda: axes.plot(lambda x: np.sin(x - t.get_value()), color=BLUE))\n        self.add(axes, curve)\n        self.play(t.animate.set_value(4*PI), run_time=4, rate_func=linear)\n        self.wait()"}
{"prompt": "Show a fractal tree growing", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        def create_branch(start, angle, length, depth):\n            if depth == 0 or length < 0.05:\n                return VGroup()\n            end = start + length * np.array([np.cos(angle), np.sin(angle), 0])\n            line = Line(start, end, color=GREEN, stroke_width=max(1, depth))\n            left = create_branch(end, angle + PI/6, length*0.7, depth-1)\n            right = create_branch(end, angle - PI/6, length*0.7, depth-1)\n            return VGroup(line, left, right)\n        tree = create_branch(DOWN*3, PI/2, 2.5, 8)\n        self.play(Create(tree), run_time=4)\n        self.wait()"}
{"prompt": "Create a loading spinner animation with dots", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        dots = VGroup()\n        for i in range(8):\n            angle = i * TAU / 8\n            dot = Dot(radius=0.12, color=WHITE)\n            dot.move_to(1.5 * np.array([np.cos(angle), np.sin(angle), 0]))\n            dot.set_opacity(0.3 + 0.7 * (i / 8))\n            dots.add(dot)\n        self.add(dots)\n        self.play(Rotate(dots, angle=TAU), run_time=2, rate_func=linear)\n        self.play(Rotate(dots, angle=TAU), run_time=2, rate_func=linear)\n        self.wait()"}
{"prompt": "Show a coordinate system with a parabola y=x^2", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        axes = Axes(x_range=[-3, 3, 1], y_range=[-1, 9, 1], axis_config={'include_numbers': True})\n        parabola = axes.plot(lambda x: x**2, color=YELLOW)\n        label = axes.get_graph_label(parabola, label='y=x^2')\n        self.play(Create(axes))\n        self.play(Create(parabola), Write(label), run_time=2)\n        self.wait()"}
{"prompt": "Animate text changing from Hello to Goodbye", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        hello = Text('Hello', font_size=72, color=GREEN)\n        goodbye = Text('Goodbye', font_size=72, color=RED)\n        self.play(Write(hello))\n        self.wait(0.5)\n        self.play(TransformMatchingShapes(hello, goodbye))\n        self.wait()"}
{"prompt": "Create a Venn diagram with two overlapping circles", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        c1 = Circle(radius=1.5, color=BLUE, fill_opacity=0.3).shift(LEFT*0.8)\n        c2 = Circle(radius=1.5, color=RED, fill_opacity=0.3).shift(RIGHT*0.8)\n        l1 = Text('A', font_size=48).move_to(LEFT*1.8)\n        l2 = Text('B', font_size=48).move_to(RIGHT*1.8)\n        l3 = Text('A∩B', font_size=32).move_to(ORIGIN)\n        self.play(Create(c1), Create(c2))\n        self.play(Write(l1), Write(l2), Write(l3))\n        self.wait()"}
{"prompt": "Show a progress bar filling from 0% to 100%", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        bg_bar = Rectangle(width=8, height=0.6, color=GRAY, fill_opacity=0.3)\n        fill_bar = Rectangle(width=0.01, height=0.6, color=GREEN, fill_opacity=0.8).align_to(bg_bar, LEFT)\n        pct = DecimalNumber(0, num_decimal_places=0, font_size=48, unit='\\\\%').next_to(bg_bar, UP)\n        self.add(bg_bar)\n        self.play(\n            fill_bar.animate.stretch_to_fit_width(8).align_to(bg_bar, LEFT),\n            ChangeDecimalToValue(pct, 100),\n            run_time=3\n        )\n        self.wait()"}
{"prompt": "Create a 3D surface plot of z = sin(x)*cos(y)", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(ThreeDScene):\n    def construct(self):\n        axes = ThreeDAxes(x_range=[-3, 3], y_range=[-3, 3], z_range=[-1.5, 1.5])\n        surface = Surface(\n            lambda u, v: axes.c2p(u, v, np.sin(u)*np.cos(v)),\n            u_range=[-3, 3],\n            v_range=[-3, 3],\n            resolution=(30, 30),\n            fill_opacity=0.7\n        )\n        surface.set_color_by_gradient(BLUE, GREEN, YELLOW)\n        self.set_camera_orientation(phi=70*DEGREES, theta=30*DEGREES)\n        self.play(Create(axes), Create(surface), run_time=2)\n        self.begin_ambient_camera_rotation(rate=0.3)\n        self.wait(3)"}
{"prompt": "Show Newton's second law F=ma with explanation text", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text(\"Newton's Second Law\", font_size=48).to_edge(UP)\n        formula = MathTex('F', '=', 'm', '\\\\cdot', 'a', font_size=96)\n        formula[0].set_color(RED)\n        formula[2].set_color(BLUE)\n        formula[4].set_color(GREEN)\n        desc_f = Text('Force', font_size=28, color=RED).next_to(formula, DOWN, buff=0.8).shift(LEFT*2)\n        desc_m = Text('Mass', font_size=28, color=BLUE).next_to(formula, DOWN, buff=0.8)\n        desc_a = Text('Acceleration', font_size=28, color=GREEN).next_to(formula, DOWN, buff=0.8).shift(RIGHT*2.5)\n        self.play(Write(title))\n        self.play(Write(formula))\n        self.play(FadeIn(desc_f), FadeIn(desc_m), FadeIn(desc_a))\n        self.wait()"}
{"prompt": "Create a grid of colored squares like a checkerboard", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        grid = VGroup()\n        for i in range(8):\n            for j in range(8):\n                color = WHITE if (i+j) % 2 == 0 else DARK_GRAY\n                sq = Square(side_length=0.6, fill_opacity=0.9, fill_color=color, stroke_width=0.5)\n                sq.move_to(RIGHT*(j*0.6 - 2.1) + UP*(i*0.6 - 2.1))\n                grid.add(sq)\n        self.play(Create(grid), run_time=2)\n        self.wait()"}
{"prompt": "Animate a circle's radius growing from 0.5 to 3 with a tracker showing the value", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        r = ValueTracker(0.5)\n        circle = always_redraw(lambda: Circle(radius=r.get_value(), color=BLUE))\n        label = always_redraw(lambda: Text(f'r = {r.get_value():.1f}', font_size=36).to_edge(UP))\n        self.add(circle, label)\n        self.play(r.animate.set_value(3), run_time=3)\n        self.wait()"}
{"prompt": "Show the quadratic formula step by step", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        eq1 = MathTex('ax^2 + bx + c = 0', font_size=56)\n        eq2 = MathTex('x = \\\\frac{-b \\\\pm \\\\sqrt{b^2 - 4ac}}{2a}', font_size=56)\n        title = Text('The Quadratic Formula', font_size=42).to_edge(UP)\n        self.play(Write(title))\n        self.play(Write(eq1))\n        self.wait(0.5)\n        self.play(eq1.animate.shift(UP))\n        eq2.next_to(eq1, DOWN, buff=0.8)\n        self.play(Write(eq2))\n        self.play(Indicate(eq2))\n        self.wait()"}
{"prompt": "Create a DNA double helix using 3D", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(ThreeDScene):\n    def construct(self):\n        self.set_camera_orientation(phi=70*DEGREES, theta=20*DEGREES)\n        helix1 = ParametricFunction(\n            lambda t: np.array([np.cos(t), np.sin(t), t/2]),\n            t_range=[0, 4*PI],\n            color=BLUE\n        )\n        helix2 = ParametricFunction(\n            lambda t: np.array([np.cos(t+PI), np.sin(t+PI), t/2]),\n            t_range=[0, 4*PI],\n            color=RED\n        )\n        rungs = VGroup()\n        for t in np.linspace(0, 4*PI, 20):\n            p1 = np.array([np.cos(t), np.sin(t), t/2])\n            p2 = np.array([np.cos(t+PI), np.sin(t+PI), t/2])\n            rung = Line3D(p1, p2, color=GREEN)\n            rungs.add(rung)\n        dna = VGroup(helix1, helix2, rungs).move_to(ORIGIN)\n        self.play(Create(dna), run_time=3)\n        self.begin_ambient_camera_rotation(rate=0.4)\n        self.wait(3)"}
{"prompt": "Show a timeline with 4 events", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        line = Line(LEFT*5, RIGHT*5, color=WHITE)\n        events = [\n            ('1990', 'WWW'),\n            ('2000', 'Y2K'),\n            ('2010', 'Mobile'),\n            ('2020', 'AI Boom'),\n        ]\n        dots = VGroup()\n        labels = VGroup()\n        for i, (year, name) in enumerate(events):\n            x = -3.5 + i * 2.3\n            dot = Dot(point=[x, 0, 0], color=YELLOW, radius=0.12)\n            year_text = Text(year, font_size=24).next_to(dot, DOWN, buff=0.3)\n            name_text = Text(name, font_size=20, color=BLUE).next_to(dot, UP, buff=0.3)\n            dots.add(dot)\n            labels.add(year_text, name_text)\n        self.play(Create(line))\n        self.play(Create(dots), Write(labels), run_time=2)\n        self.wait()"}
{"prompt": "Animate a pendulum swinging back and forth", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        pivot = Dot(UP*3, color=WHITE, radius=0.08)\n        angle = ValueTracker(PI/4)\n        rod = always_redraw(lambda: Line(\n            UP*3,\n            UP*3 + 2.5*np.array([np.sin(angle.get_value()), -np.cos(angle.get_value()), 0]),\n            color=WHITE\n        ))\n        bob = always_redraw(lambda: Dot(\n            UP*3 + 2.5*np.array([np.sin(angle.get_value()), -np.cos(angle.get_value()), 0]),\n            color=RED, radius=0.2\n        ))\n        self.add(pivot, rod, bob)\n        for _ in range(3):\n            self.play(angle.animate.set_value(-PI/4), run_time=1, rate_func=there_and_back)\n        self.wait()"}
{"prompt": "Create a neural network diagram with 3 layers", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        layers = [3, 4, 2]\n        neurons = VGroup()\n        edges = VGroup()\n        all_layer_neurons = []\n        for l, count in enumerate(layers):\n            layer_neurons = VGroup()\n            for n in range(count):\n                y = (n - (count-1)/2) * 1.2\n                neuron = Circle(radius=0.25, color=BLUE, fill_opacity=0.3).move_to([l*3 - 3, y, 0])\n                layer_neurons.add(neuron)\n            all_layer_neurons.append(layer_neurons)\n            neurons.add(layer_neurons)\n        for l in range(len(layers)-1):\n            for n1 in all_layer_neurons[l]:\n                for n2 in all_layer_neurons[l+1]:\n                    edge = Line(n1.get_center(), n2.get_center(), color=GRAY, stroke_width=1)\n                    edges.add(edge)\n        labels = VGroup(\n            Text('Input', font_size=24).next_to(all_layer_neurons[0], DOWN, buff=0.5),\n            Text('Hidden', font_size=24).next_to(all_layer_neurons[1], DOWN, buff=0.5),\n            Text('Output', font_size=24).next_to(all_layer_neurons[2], DOWN, buff=0.5),\n        )\n        self.play(Create(edges), run_time=1)\n        self.play(Create(neurons), run_time=1)\n        self.play(Write(labels))\n        self.wait()"}
{"prompt": "Show a color wheel with 6 colors", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        colors = [RED, YELLOW, GREEN, TEAL, BLUE, PURPLE]\n        wheel = VGroup()\n        for i, color in enumerate(colors):\n            sector = Sector(\n                outer_radius=2,\n                angle=TAU/6,\n                start_angle=i*TAU/6,\n                color=color,\n                fill_opacity=0.8\n            )\n            wheel.add(sector)\n        self.play(Create(wheel), run_time=2)\n        self.play(Rotate(wheel, TAU), run_time=2)\n        self.wait()"}
{"prompt": "Create a table showing multiplication facts for 5", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        table = Table(\n            [['5 x 1', '5'],\n             ['5 x 2', '10'],\n             ['5 x 3', '15'],\n             ['5 x 4', '20'],\n             ['5 x 5', '25']],\n            col_labels=[Text('Expression'), Text('Result')]\n        ).scale(0.7)\n        self.play(Create(table), run_time=2)\n        self.wait()"}
{"prompt": "Animate the area under a curve being filled in", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        axes = Axes(x_range=[0, 5, 1], y_range=[0, 5, 1])\n        curve = axes.plot(lambda x: 0.2*x**2, x_range=[0, 4], color=BLUE)\n        area = axes.get_area(curve, x_range=[0, 4], color=BLUE, opacity=0.3)\n        label = MathTex('\\\\int_0^4 0.2x^2 \\\\, dx', font_size=36).to_edge(UP)\n        self.play(Create(axes))\n        self.play(Create(curve))\n        self.play(FadeIn(area), Write(label), run_time=2)\n        self.wait()"}
{"prompt": "Show a clock with hands that move", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        clock_face = Circle(radius=2.5, color=WHITE)\n        center_dot = Dot(ORIGIN, color=WHITE, radius=0.08)\n        numbers = VGroup()\n        for i in range(1, 13):\n            angle = PI/2 - i * TAU/12\n            pos = 2.1 * np.array([np.cos(angle), np.sin(angle), 0])\n            num = Text(str(i), font_size=28).move_to(pos)\n            numbers.add(num)\n        hour_hand = Line(ORIGIN, UP*1.2, color=WHITE, stroke_width=6)\n        minute_hand = Line(ORIGIN, UP*1.8, color=BLUE, stroke_width=3)\n        self.play(Create(clock_face), Write(numbers), Create(center_dot))\n        self.add(hour_hand, minute_hand)\n        self.play(\n            Rotate(minute_hand, -TAU, about_point=ORIGIN),\n            Rotate(hour_hand, -TAU/12, about_point=ORIGIN),\n            run_time=4, rate_func=linear\n        )\n        self.wait()"}
{"prompt": "Create an animated scatter plot with random points appearing", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        np.random.seed(42)\n        axes = Axes(x_range=[0, 10, 2], y_range=[0, 10, 2], axis_config={'include_numbers': True})\n        self.play(Create(axes))\n        dots = VGroup()\n        for _ in range(20):\n            x, y = np.random.uniform(1, 9, 2)\n            dot = Dot(axes.c2p(x, y), color=YELLOW, radius=0.08)\n            dots.add(dot)\n        self.play(LaggedStart(*[FadeIn(d, scale=0.5) for d in dots], lag_ratio=0.1))\n        self.wait()"}
{"prompt": "Show a stacked list of items appearing one by one", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Shopping List', font_size=48, color=YELLOW).to_edge(UP)\n        items = ['Apples', 'Bread', 'Milk', 'Eggs', 'Cheese']\n        item_group = VGroup()\n        for i, item in enumerate(items):\n            bullet = Text(f'• {item}', font_size=36)\n            bullet.move_to(UP*(1 - i*0.8) + LEFT*1)\n            bullet.align_to(LEFT*2, LEFT)\n            item_group.add(bullet)\n        self.play(Write(title))\n        for item in item_group:\n            self.play(FadeIn(item, shift=RIGHT*0.5), run_time=0.5)\n        self.wait()"}
{"prompt": "Create a spiral that draws itself", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        spiral = ParametricFunction(\n            lambda t: np.array([t/8 * np.cos(t), t/8 * np.sin(t), 0]),\n            t_range=[0, 6*PI],\n            color=BLUE\n        )\n        self.play(Create(spiral), run_time=4)\n        self.wait()"}
{"prompt": "Show two graphs side by side comparing linear vs exponential growth", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        ax1 = Axes(x_range=[0, 5, 1], y_range=[0, 10, 2]).scale(0.45).shift(LEFT*3.2)\n        ax2 = Axes(x_range=[0, 5, 1], y_range=[0, 50, 10]).scale(0.45).shift(RIGHT*3.2)\n        linear = ax1.plot(lambda x: 2*x, color=BLUE)\n        exponential = ax2.plot(lambda x: 2**x, color=RED)\n        l1 = Text('Linear: y=2x', font_size=24, color=BLUE).next_to(ax1, UP)\n        l2 = Text('Exponential: y=2^x', font_size=24, color=RED).next_to(ax2, UP)\n        self.play(Create(ax1), Create(ax2))\n        self.play(Create(linear), Write(l1))\n        self.play(Create(exponential), Write(l2))\n        self.wait()"}
{"prompt": "Create a bouncing ball animation", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        ground = Line(LEFT*5, RIGHT*5, color=WHITE).shift(DOWN*3)\n        ball = Dot(radius=0.3, color=RED).move_to(UP*2)\n        self.add(ground)\n        self.play(Create(ball))\n        heights = [2, 1.2, 0.6, 0.3]\n        for h in heights:\n            self.play(\n                ball.animate.move_to(DOWN*2.7),\n                run_time=0.4, rate_func=rush_into\n            )\n            self.play(\n                ball.animate.move_to(UP*h),\n                run_time=0.4, rate_func=rush_from\n            )\n        self.play(ball.animate.move_to(DOWN*2.7), run_time=0.3)\n        self.wait()"}
{"prompt": "Show a transformation matrix rotating a square by 45 degrees", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        plane = NumberPlane()\n        square = Square(side_length=2, color=BLUE, fill_opacity=0.3)\n        theta = PI/4\n        matrix = [[np.cos(theta), -np.sin(theta)], [np.sin(theta), np.cos(theta)]]\n        matrix_tex = MathTex(\n            r'R_{45°} = \\begin{bmatrix} \\cos 45° & -\\sin 45° \\\\ \\sin 45° & \\cos 45° \\end{bmatrix}',\n            font_size=36\n        ).to_edge(UP)\n        self.add(plane)\n        self.play(Create(square), Write(matrix_tex))\n        self.play(ApplyMatrix(matrix, square), run_time=2)\n        self.wait()"}
{"prompt": "Create a fading trail of circles moving to the right", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        dots = VGroup()\n        for i in range(10):\n            c = Circle(radius=0.3, color=BLUE, fill_opacity=1-i*0.1)\n            c.shift(RIGHT*(i*0.6 - 2.5))\n            dots.add(c)\n        self.play(LaggedStart(*[FadeIn(d) for d in dots], lag_ratio=0.15))\n        self.play(dots.animate.shift(RIGHT*3), run_time=2)\n        self.wait()"}
{"prompt": "Show a graph of y=1/x with asymptotes", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        axes = Axes(x_range=[-5, 5, 1], y_range=[-5, 5, 1], axis_config={'include_numbers': True})\n        graph_pos = axes.plot(lambda x: 1/x, x_range=[0.2, 5], color=YELLOW)\n        graph_neg = axes.plot(lambda x: 1/x, x_range=[-5, -0.2], color=YELLOW)\n        v_asymptote = DashedLine(axes.c2p(0, -5), axes.c2p(0, 5), color=RED)\n        h_asymptote = DashedLine(axes.c2p(-5, 0), axes.c2p(5, 0), color=RED)\n        label = MathTex('y = \\\\frac{1}{x}', font_size=36).to_corner(UR)\n        self.play(Create(axes))\n        self.play(Create(graph_pos), Create(graph_neg))\n        self.play(Create(v_asymptote), Create(h_asymptote), Write(label))\n        self.wait()"}
{"prompt": "Animate a square being divided into 4 smaller squares", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        big_square = Square(side_length=3, color=WHITE)\n        self.play(Create(big_square))\n        h_line = Line(big_square.get_left(), big_square.get_right(), color=YELLOW)\n        v_line = Line(big_square.get_top(), big_square.get_bottom(), color=YELLOW)\n        self.play(Create(h_line), Create(v_line))\n        colors = [RED, BLUE, GREEN, ORANGE]\n        small_squares = VGroup()\n        for i, (dx, dy) in enumerate([(-0.75, 0.75), (0.75, 0.75), (-0.75, -0.75), (0.75, -0.75)]):\n            sq = Square(side_length=1.5, fill_color=colors[i], fill_opacity=0.5, stroke_width=0)\n            sq.move_to([dx, dy, 0])\n            small_squares.add(sq)\n        self.play(FadeIn(small_squares))\n        self.wait()"}
{"prompt": "Create a simple flowchart with three boxes and arrows", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        box1 = Rectangle(width=2.5, height=1, color=BLUE, fill_opacity=0.3).shift(UP*2)\n        box2 = Rectangle(width=2.5, height=1, color=GREEN, fill_opacity=0.3)\n        box3 = Rectangle(width=2.5, height=1, color=RED, fill_opacity=0.3).shift(DOWN*2)\n        t1 = Text('Start', font_size=28).move_to(box1)\n        t2 = Text('Process', font_size=28).move_to(box2)\n        t3 = Text('End', font_size=28).move_to(box3)\n        a1 = Arrow(box1.get_bottom(), box2.get_top(), buff=0.1)\n        a2 = Arrow(box2.get_bottom(), box3.get_top(), buff=0.1)\n        self.play(Create(box1), Write(t1))\n        self.play(GrowArrow(a1))\n        self.play(Create(box2), Write(t2))\n        self.play(GrowArrow(a2))\n        self.play(Create(box3), Write(t3))\n        self.wait()"}
{"prompt": "Display the derivative rules: power rule, product rule, chain rule", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Derivative Rules', font_size=48, color=YELLOW).to_edge(UP)\n        rules = VGroup(\n            MathTex('\\\\text{Power: } \\\\frac{d}{dx}x^n = nx^{n-1}', font_size=40),\n            MathTex('\\\\text{Product: } (fg)\\' = f\\'g + fg\\'', font_size=40),\n            MathTex('\\\\text{Chain: } \\\\frac{d}{dx}f(g(x)) = f\\'(g(x)) \\\\cdot g\\'(x)', font_size=40),\n        ).arrange(DOWN, buff=0.8)\n        self.play(Write(title))\n        for rule in rules:\n            self.play(Write(rule))\n        self.wait()"}
{"prompt": "Show a wave interference pattern with two sources", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        axes = Axes(x_range=[-5, 5, 1], y_range=[-3, 3, 1])\n        wave1 = axes.plot(lambda x: np.sin(2*x), color=BLUE)\n        wave2 = axes.plot(lambda x: np.sin(2*x + PI/3), color=RED)\n        combined = axes.plot(lambda x: np.sin(2*x) + np.sin(2*x + PI/3), color=GREEN)\n        l1 = Text('Wave 1', font_size=24, color=BLUE).to_corner(UL)\n        l2 = Text('Wave 2', font_size=24, color=RED).next_to(l1, DOWN, aligned_edge=LEFT)\n        l3 = Text('Combined', font_size=24, color=GREEN).next_to(l2, DOWN, aligned_edge=LEFT)\n        self.play(Create(axes))\n        self.play(Create(wave1), Write(l1))\n        self.play(Create(wave2), Write(l2))\n        self.play(Create(combined), Write(l3))\n        self.wait()"}
{"prompt": "Create an animation of a coin flip showing heads and tails", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        coin = Circle(radius=1.5, color=GOLD, fill_opacity=0.8)\n        heads_text = Text('H', font_size=72, color=WHITE)\n        tails_text = Text('T', font_size=72, color=WHITE)\n        coin_group = VGroup(coin, heads_text)\n        self.play(Create(coin_group))\n        for _ in range(3):\n            self.play(coin_group.animate.stretch(0.01, 0), run_time=0.2)\n            heads_text.become(tails_text.copy() if heads_text.text == 'H' else Text('H', font_size=72, color=WHITE))\n            self.play(coin_group.animate.stretch(100, 0), run_time=0.2)\n        self.wait()"}
{"prompt": "Draw concentric circles with decreasing opacity", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        circles = VGroup()\n        for i in range(8):\n            r = 0.5 + i * 0.35\n            c = Circle(radius=r, color=BLUE, stroke_opacity=1-i*0.1)\n            circles.add(c)\n        self.play(LaggedStart(*[Create(c) for c in circles], lag_ratio=0.2))\n        self.wait()"}
{"prompt": "Show the distributive property a(b+c) = ab + ac with colors", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Distributive Property', font_size=42).to_edge(UP)\n        left = MathTex('a', '(', 'b', '+', 'c', ')', font_size=72)\n        equals = MathTex('=', font_size=72)\n        right = MathTex('a', 'b', '+', 'a', 'c', font_size=72)\n        left[0].set_color(RED)\n        left[2].set_color(BLUE)\n        left[4].set_color(GREEN)\n        right[0].set_color(RED)\n        right[1].set_color(BLUE)\n        right[3].set_color(RED)\n        right[4].set_color(GREEN)\n        equation = VGroup(left, equals, right).arrange(RIGHT, buff=0.3)\n        self.play(Write(title))\n        self.play(Write(left))\n        self.wait(0.5)\n        self.play(Write(equals), Write(right))\n        self.wait()"}
{"prompt": "Create an animated gradient line that changes color", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        line = Line(LEFT*5, RIGHT*5, stroke_width=8)\n        line.set_color(color=[RED, ORANGE, YELLOW, GREEN, BLUE, PURPLE])\n        self.play(Create(line), run_time=3)\n        self.play(line.animate.set_color(color=[PURPLE, BLUE, GREEN, YELLOW, ORANGE, RED]), run_time=2)\n        self.wait()"}
{"prompt": "Display a truth table for AND logic gate", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('AND Gate Truth Table', font_size=40).to_edge(UP)\n        table = Table(\n            [['0', '0', '0'],\n             ['0', '1', '0'],\n             ['1', '0', '0'],\n             ['1', '1', '1']],\n            col_labels=[Text('A'), Text('B'), Text('A AND B')]\n        ).scale(0.65)\n        self.play(Write(title))\n        self.play(Create(table), run_time=2)\n        self.wait()"}
{"prompt": "Show a dot orbit around an ellipse path", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        ellipse = Ellipse(width=5, height=3, color=WHITE)\n        sun = Dot(ORIGIN, color=YELLOW, radius=0.2)\n        planet = Dot(color=BLUE, radius=0.12).move_to(ellipse.point_from_proportion(0))\n        orbit_label = Text('Orbit', font_size=28, color=GRAY).next_to(ellipse, UP)\n        self.play(Create(ellipse), Create(sun), Write(orbit_label))\n        self.play(MoveAlongPath(planet, ellipse), run_time=4, rate_func=linear)\n        self.wait()"}
{"prompt": "Create a histogram from random data", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        np.random.seed(0)\n        data = np.random.normal(5, 1.5, 200)\n        bins = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n        counts, _ = np.histogram(data, bins=bins)\n        max_count = max(counts)\n        bars = VGroup()\n        for i, count in enumerate(counts):\n            height = count / max_count * 4\n            bar = Rectangle(width=0.7, height=height, fill_color=BLUE, fill_opacity=0.7, color=WHITE)\n            bar.move_to(RIGHT*(i*0.8 - 3.6) + UP*height/2 - UP*2)\n            bars.add(bar)\n        x_labels = VGroup(*[Text(str(b), font_size=20).move_to(RIGHT*(i*0.8 - 3.6) + DOWN*2.3) for i, b in enumerate(bins[:-1])])\n        title = Text('Normal Distribution', font_size=36).to_edge(UP)\n        self.play(Write(title))\n        self.play(LaggedStart(*[GrowFromEdge(b, DOWN) for b in bars], lag_ratio=0.1))\n        self.play(Write(x_labels))\n        self.wait()"}
{"prompt": "Show Taylor series expansion of e^x", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Taylor Series of e^x', font_size=42).to_edge(UP)\n        formula = MathTex(\n            'e^x = 1 + x + \\\\frac{x^2}{2!} + \\\\frac{x^3}{3!} + \\\\cdots',\n            font_size=48\n        )\n        expanded = MathTex(\n            'e^x = \\\\sum_{n=0}^{\\\\infty} \\\\frac{x^n}{n!}',\n            font_size=56\n        ).shift(DOWN*1.5)\n        self.play(Write(title))\n        self.play(Write(formula))\n        self.wait(0.5)\n        self.play(Write(expanded))\n        self.play(Indicate(expanded))\n        self.wait()"}
{"prompt": "Create a pulsing heart shape", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        heart = ParametricFunction(\n            lambda t: np.array([\n                16 * np.sin(t)**3,\n                13 * np.cos(t) - 5 * np.cos(2*t) - 2 * np.cos(3*t) - np.cos(4*t),\n                0\n            ]) / 10,\n            t_range=[0, TAU],\n            color=RED,\n            fill_opacity=0.8\n        )\n        self.play(Create(heart))\n        for _ in range(3):\n            self.play(heart.animate.scale(1.2), run_time=0.3)\n            self.play(heart.animate.scale(1/1.2), run_time=0.3)\n        self.wait()"}
{"prompt": "Demonstrate matrix multiplication step by step", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        m1 = Matrix([[1, 2], [3, 4]], left_bracket='(', right_bracket=')').shift(LEFT*3)\n        times = MathTex('\\\\times', font_size=48)\n        m2 = Matrix([[5, 6], [7, 8]], left_bracket='(', right_bracket=')').shift(RIGHT*0.5)\n        equals = MathTex('=', font_size=48).shift(RIGHT*3)\n        result = Matrix([[19, 22], [43, 50]], left_bracket='(', right_bracket=')').shift(RIGHT*5)\n        self.play(Write(m1))\n        self.play(Write(times), Write(m2))\n        self.wait(0.5)\n        self.play(Write(equals), Write(result))\n        self.wait()"}
{"prompt": "Create a binary tree data structure visualization", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        nodes = {}\n        positions = {1: [0, 2.5, 0], 2: [-2, 1, 0], 3: [2, 1, 0], 4: [-3, -0.5, 0], 5: [-1, -0.5, 0], 6: [1, -0.5, 0], 7: [3, -0.5, 0]}\n        values = {1: '8', 2: '4', 3: '12', 4: '2', 5: '6', 6: '10', 7: '14'}\n        node_group = VGroup()\n        edge_group = VGroup()\n        for key, pos in positions.items():\n            circle = Circle(radius=0.4, color=BLUE, fill_opacity=0.3).move_to(pos)\n            label = Text(values[key], font_size=28).move_to(pos)\n            nodes[key] = VGroup(circle, label)\n            node_group.add(nodes[key])\n        for parent, child in [(1,2),(1,3),(2,4),(2,5),(3,6),(3,7)]:\n            edge = Line(positions[parent], positions[child], color=GRAY, buff=0.4)\n            edge_group.add(edge)\n        self.play(Create(edge_group), run_time=1)\n        self.play(LaggedStart(*[Create(n) for n in node_group], lag_ratio=0.15))\n        self.wait()"}
{"prompt": "Show a ball rolling down a ramp", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        ramp = Line(LEFT*4 + UP*2, RIGHT*2 + DOWN*2, color=WHITE, stroke_width=4)\n        ground = Line(RIGHT*2 + DOWN*2, RIGHT*5 + DOWN*2, color=WHITE, stroke_width=4)\n        ball = Dot(radius=0.25, color=RED).move_to(LEFT*3.5 + UP*2.3)\n        self.add(ramp, ground)\n        self.play(Create(ball))\n        self.play(MoveAlongPath(ball, Line(LEFT*3.5 + UP*2.3, RIGHT*2 + DOWN*1.75)), run_time=1.5, rate_func=rush_into)\n        self.play(ball.animate.shift(RIGHT*2.5), run_time=1.5, rate_func=linear)\n        self.wait()"}
{"prompt": "Display the electromagnetic spectrum with labeled regions", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Electromagnetic Spectrum', font_size=36).to_edge(UP)\n        regions = [\n            ('Radio', RED),\n            ('Micro', ORANGE),\n            ('IR', YELLOW),\n            ('Visible', GREEN),\n            ('UV', BLUE),\n            ('X-ray', PURPLE),\n            ('Gamma', PINK),\n        ]\n        bars = VGroup()\n        labels = VGroup()\n        for i, (name, color) in enumerate(regions):\n            bar = Rectangle(width=1.5, height=1.2, fill_color=color, fill_opacity=0.7, color=WHITE)\n            bar.shift(RIGHT*(i*1.6 - 4.8))\n            label = Text(name, font_size=18).next_to(bar, DOWN, buff=0.2)\n            bars.add(bar)\n            labels.add(label)\n        arrow = Arrow(LEFT*5.5, RIGHT*5.5, color=WHITE).shift(DOWN*1.8)\n        low = Text('Low freq', font_size=20).next_to(arrow, LEFT, buff=0.1).shift(DOWN*0.3)\n        high = Text('High freq', font_size=20).next_to(arrow, RIGHT, buff=0.1).shift(DOWN*0.3)\n        self.play(Write(title))\n        self.play(LaggedStart(*[GrowFromCenter(b) for b in bars], lag_ratio=0.1))\n        self.play(Write(labels), GrowArrow(arrow), Write(low), Write(high))\n        self.wait()"}
{"prompt": "Create a simple state machine diagram with 3 states", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        s1 = Circle(radius=0.6, color=GREEN, fill_opacity=0.3).shift(LEFT*3)\n        s2 = Circle(radius=0.6, color=BLUE, fill_opacity=0.3)\n        s3 = Circle(radius=0.6, color=RED, fill_opacity=0.3).shift(RIGHT*3)\n        l1 = Text('Idle', font_size=22).move_to(s1)\n        l2 = Text('Run', font_size=22).move_to(s2)\n        l3 = Text('Stop', font_size=22).move_to(s3)\n        a1 = Arrow(s1.get_right(), s2.get_left(), buff=0.1)\n        a2 = Arrow(s2.get_right(), s3.get_left(), buff=0.1)\n        a3 = CurvedArrow(s3.get_top(), s1.get_top(), angle=-TAU/4, color=GRAY)\n        al1 = Text('start', font_size=18).next_to(a1, UP, buff=0.1)\n        al2 = Text('finish', font_size=18).next_to(a2, UP, buff=0.1)\n        al3 = Text('reset', font_size=18, color=GRAY).shift(UP*2)\n        self.play(Create(s1), Write(l1), Create(s2), Write(l2), Create(s3), Write(l3))\n        self.play(GrowArrow(a1), Write(al1))\n        self.play(GrowArrow(a2), Write(al2))\n        self.play(Create(a3), Write(al3))\n        self.wait()"}
{"prompt": "Animate text with a typewriter effect one character at a time", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        text = Text('Hello, World!', font_size=64)\n        cursor = Rectangle(width=0.08, height=0.8, color=WHITE, fill_opacity=1).next_to(text[0], LEFT, buff=0.05)\n        self.add(cursor)\n        for i, char in enumerate(text):\n            self.play(FadeIn(char, shift=UP*0.1), run_time=0.1)\n            cursor.next_to(char, RIGHT, buff=0.05)\n        self.play(FadeOut(cursor))\n        self.wait()"}
{"prompt": "Show the Fibonacci sequence visually with golden rectangles", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Fibonacci Golden Rectangles', font_size=36).to_edge(UP)\n        fibs = [1, 1, 2, 3, 5]\n        colors = [RED, BLUE, GREEN, YELLOW, PURPLE]\n        scale = 0.4\n        rects = VGroup()\n        pos = ORIGIN\n        directions = [RIGHT, UP, LEFT, DOWN]\n        for i, f in enumerate(fibs):\n            rect = Square(side_length=f*scale, color=colors[i], fill_opacity=0.3)\n            if i == 0:\n                rect.move_to(pos)\n            elif i == 1:\n                rect.next_to(rects[-1], directions[0], buff=0)\n            else:\n                rect.next_to(VGroup(*rects[-2:]), directions[i%4], buff=0)\n            rects.add(rect)\n        group = VGroup(*rects).move_to(ORIGIN)\n        self.play(Write(title))\n        for r in rects:\n            self.play(Create(r), run_time=0.5)\n        self.wait()"}
{"prompt": "Create a sunrise animation with a circle rising and color change", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        sky = Rectangle(width=14, height=8, fill_opacity=1, fill_color=DARK_BLUE)\n        ground = Rectangle(width=14, height=2, fill_opacity=1, fill_color=DARK_GRAY).align_to(sky, DOWN)\n        sun = Circle(radius=0.8, color=YELLOW, fill_opacity=1).shift(DOWN*4)\n        self.add(sky, ground)\n        self.play(\n            sun.animate.shift(UP*5),\n            sky.animate.set_fill(color=[ORANGE, BLUE]),\n            run_time=4\n        )\n        self.wait()"}
{"prompt": "Show vector cross product in 3D", "code": "from manim import *\n\nclass GenScene(ThreeDScene):\n    def construct(self):\n        self.set_camera_orientation(phi=65*DEGREES, theta=45*DEGREES)\n        axes = ThreeDAxes(x_range=[-3, 3], y_range=[-3, 3], z_range=[-3, 3])\n        v1 = Arrow3D(ORIGIN, [2, 0, 0], color=RED)\n        v2 = Arrow3D(ORIGIN, [0, 2, 0], color=BLUE)\n        cross = Arrow3D(ORIGIN, [0, 0, 2], color=GREEN)\n        l1 = MathTex('\\\\vec{a}', color=RED, font_size=36).move_to([2.5, 0, 0])\n        l2 = MathTex('\\\\vec{b}', color=BLUE, font_size=36).move_to([0, 2.5, 0])\n        l3 = MathTex('\\\\vec{a} \\\\times \\\\vec{b}', color=GREEN, font_size=30).move_to([0, 0, 2.8])\n        self.play(Create(axes))\n        self.play(Create(v1), Write(l1))\n        self.play(Create(v2), Write(l2))\n        self.play(Create(cross), Write(l3))\n        self.wait()"}
{"prompt": "Animate sorting a list of numbers with insertion sort", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        values = [5, 3, 8, 1, 7]\n        squares = VGroup()\n        for i, v in enumerate(values):\n            sq = Square(side_length=1, color=WHITE)\n            num = Text(str(v), font_size=36)\n            group = VGroup(sq, num).move_to(RIGHT*(i*1.3 - 2.6))\n            squares.add(group)\n        self.play(Create(squares))\n        for i in range(1, len(values)):\n            key = values[i]\n            squares[i][0].set_color(YELLOW)\n            self.play(squares[i].animate.shift(UP*1.5), run_time=0.3)\n            j = i - 1\n            while j >= 0 and values[j] > key:\n                values[j+1] = values[j]\n                self.play(squares[j].animate.shift(RIGHT*1.3), run_time=0.3)\n                squares[j+1] = squares[j]\n                j -= 1\n            values[j+1] = key\n            target_pos = RIGHT*((j+1)*1.3 - 2.6)\n            self.play(squares[i].animate.move_to(target_pos), run_time=0.3)\n            squares[j+1] = squares[i]\n            squares[j+1][0].set_color(GREEN)\n        self.wait()"}
{"prompt": "Create a donut chart with 3 segments", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        segments = [(0.5, BLUE, 'Sales 50%'), (0.3, RED, 'Marketing 30%'), (0.2, GREEN, 'R&D 20%')]\n        donut = VGroup()\n        start = 0\n        for pct, color, label_text in segments:\n            outer = Sector(outer_radius=2, angle=pct*TAU, start_angle=start, color=color, fill_opacity=0.8)\n            inner = Sector(outer_radius=1, angle=pct*TAU, start_angle=start, color=BLACK, fill_opacity=1)\n            mid_angle = start + pct*TAU/2\n            label = Text(label_text, font_size=20).move_to(2.6*np.array([np.cos(mid_angle), np.sin(mid_angle), 0]))\n            donut.add(outer, inner, label)\n            start += pct*TAU\n        self.play(Create(donut), run_time=2)\n        self.wait()"}
{"prompt": "Show a projectile motion trajectory with labeled peak", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        axes = Axes(x_range=[0, 10, 2], y_range=[0, 6, 1], axis_config={'include_numbers': True})\n        trajectory = axes.plot(lambda x: -0.1*(x-5)**2 + 2.5, x_range=[0, 10], color=YELLOW)\n        peak_dot = Dot(axes.c2p(5, 2.5), color=RED)\n        peak_label = Text('Peak', font_size=24, color=RED).next_to(peak_dot, UP)\n        ground = Line(axes.c2p(0, 0), axes.c2p(10, 0), color=GREEN, stroke_width=3)\n        title = Text('Projectile Motion', font_size=36).to_edge(UP)\n        self.play(Write(title), Create(axes))\n        self.play(Create(trajectory), run_time=2)\n        self.play(Create(peak_dot), Write(peak_label))\n        self.wait()"}
{"prompt": "Visualize a stack data structure with push and pop operations", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Stack (LIFO)', font_size=36).to_edge(UP)\n        base = Line(LEFT*1.5 + DOWN*2, RIGHT*1.5 + DOWN*2, color=WHITE)\n        left_wall = Line(LEFT*1.5 + DOWN*2, LEFT*1.5 + UP*2, color=WHITE)\n        right_wall = Line(RIGHT*1.5 + DOWN*2, RIGHT*1.5 + UP*2, color=WHITE)\n        self.play(Write(title), Create(base), Create(left_wall), Create(right_wall))\n        stack = VGroup()\n        colors = [RED, BLUE, GREEN, YELLOW]\n        for i, (val, color) in enumerate(zip([3, 7, 1, 9], colors)):\n            block = Rectangle(width=2.8, height=0.7, fill_color=color, fill_opacity=0.7, color=WHITE)\n            label = Text(str(val), font_size=28).move_to(block)\n            item = VGroup(block, label)\n            item.move_to(UP*(i*0.7 - 1.6))\n            push_label = Text('push()', font_size=22, color=GREEN).to_edge(RIGHT)\n            self.play(Write(push_label))\n            self.play(FadeIn(item, shift=DOWN), run_time=0.5)\n            self.play(FadeOut(push_label))\n            stack.add(item)\n        pop_label = Text('pop()', font_size=22, color=RED).to_edge(RIGHT)\n        self.play(Write(pop_label))\n        self.play(FadeOut(stack[-1], shift=UP), run_time=0.5)\n        self.play(FadeOut(pop_label))\n        self.wait()"}
{"prompt": "Create an animated equation solving: 2x + 3 = 7", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        step1 = MathTex('2x + 3 = 7', font_size=56)\n        step2 = MathTex('2x = 7 - 3', font_size=56)\n        step3 = MathTex('2x = 4', font_size=56)\n        step4 = MathTex('x = 2', font_size=56, color=GREEN)\n        self.play(Write(step1))\n        self.wait(0.5)\n        self.play(TransformMatchingTex(step1, step2))\n        self.wait(0.5)\n        self.play(TransformMatchingTex(step2, step3))\n        self.wait(0.5)\n        self.play(TransformMatchingTex(step3, step4))\n        self.play(Indicate(step4))\n        self.wait()"}
{"prompt": "Show a ripple effect expanding from center", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        circles = VGroup()\n        for i in range(6):\n            c = Circle(radius=0.1, color=BLUE, stroke_width=3, stroke_opacity=1)\n            circles.add(c)\n        self.play(\n            LaggedStart(\n                *[AnimationGroup(\n                    c.animate.set(width=2*(i+1)*2).set_stroke(opacity=0),\n                    run_time=2\n                ) for i, c in enumerate(circles)],\n                lag_ratio=0.3\n            )\n        )\n        self.wait()"}
{"prompt": "Create a simple pie chart showing browser market share", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Browser Market Share', font_size=36).to_edge(UP)\n        data = [('Chrome', 0.65, BLUE), ('Safari', 0.19, ORANGE), ('Firefox', 0.03, RED), ('Other', 0.13, GRAY)]\n        pie = VGroup()\n        start = 0\n        for name, pct, color in data:\n            sector = Sector(outer_radius=2, angle=pct*TAU, start_angle=start, color=color, fill_opacity=0.8)\n            mid = start + pct*TAU/2\n            label = Text(f'{name}\\n{int(pct*100)}%', font_size=18).move_to(2.6*np.array([np.cos(mid), np.sin(mid), 0]))\n            pie.add(sector, label)\n            start += pct*TAU\n        self.play(Write(title))\n        self.play(Create(pie), run_time=2)\n        self.wait()"}
{"prompt": "Animate a linked list with nodes and pointers", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Linked List', font_size=36).to_edge(UP)\n        values = [3, 7, 1, 9, 5]\n        nodes = VGroup()\n        arrows = VGroup()\n        for i, val in enumerate(values):\n            box = Rectangle(width=1.2, height=0.8, color=BLUE, fill_opacity=0.2)\n            text = Text(str(val), font_size=28)\n            node = VGroup(box, text).move_to(RIGHT*(i*2 - 4))\n            nodes.add(node)\n            if i > 0:\n                arrow = Arrow(nodes[i-1].get_right(), node.get_left(), buff=0.1, color=WHITE)\n                arrows.add(arrow)\n        null_text = Text('null', font_size=22, color=RED).next_to(nodes[-1], RIGHT, buff=0.5)\n        null_arrow = Arrow(nodes[-1].get_right(), null_text.get_left(), buff=0.1, color=RED)\n        self.play(Write(title))\n        for i in range(len(values)):\n            self.play(Create(nodes[i]), run_time=0.3)\n            if i > 0:\n                self.play(GrowArrow(arrows[i-1]), run_time=0.2)\n        self.play(GrowArrow(null_arrow), Write(null_text))\n        self.wait()"}
{"prompt": "Show the law of cosines with a triangle", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        A = LEFT*2.5 + DOWN\n        B = RIGHT*2 + DOWN\n        C = UP*1.5 + RIGHT*0.5\n        triangle = Polygon(A, B, C, color=WHITE)\n        a_label = MathTex('a', font_size=36, color=RED).move_to((B+C)/2 + RIGHT*0.3)\n        b_label = MathTex('b', font_size=36, color=BLUE).move_to((A+C)/2 + LEFT*0.3)\n        c_label = MathTex('c', font_size=36, color=GREEN).move_to((A+B)/2 + DOWN*0.3)\n        angle_arc = Angle(Line(C, A), Line(C, B), radius=0.5, color=YELLOW)\n        gamma = MathTex('\\\\gamma', font_size=28, color=YELLOW).next_to(angle_arc, DOWN, buff=0.15)\n        formula = MathTex('c^2 = a^2 + b^2 - 2ab\\\\cos(\\\\gamma)', font_size=40).to_edge(UP)\n        self.play(Create(triangle))\n        self.play(Write(a_label), Write(b_label), Write(c_label))\n        self.play(Create(angle_arc), Write(gamma))\n        self.play(Write(formula))\n        self.wait()"}
{"prompt": "Create a traffic light that changes from red to yellow to green", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        body = RoundedRectangle(width=1.8, height=5, corner_radius=0.3, color=DARK_GRAY, fill_opacity=0.9)\n        red = Circle(radius=0.6, color=DARK_GRAY, fill_opacity=0.3).shift(UP*1.5)\n        yellow = Circle(radius=0.6, color=DARK_GRAY, fill_opacity=0.3)\n        green = Circle(radius=0.6, color=DARK_GRAY, fill_opacity=0.3).shift(DOWN*1.5)\n        self.play(Create(body), Create(red), Create(yellow), Create(green))\n        self.play(red.animate.set_fill(RED, opacity=1), run_time=0.5)\n        self.wait(1)\n        self.play(red.animate.set_fill(DARK_GRAY, opacity=0.3), yellow.animate.set_fill(YELLOW, opacity=1), run_time=0.5)\n        self.wait(0.5)\n        self.play(yellow.animate.set_fill(DARK_GRAY, opacity=0.3), green.animate.set_fill(GREEN, opacity=1), run_time=0.5)\n        self.wait(1)"}
{"prompt": "Show the Pythagorean theorem proof with squares on each side", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        A = ORIGIN\n        B = RIGHT*3\n        C = UP*4\n        triangle = Polygon(A, B, C, color=WHITE, fill_opacity=0.1)\n        sq_a = Square(side_length=3, color=RED, fill_opacity=0.2).next_to(Line(A, B), DOWN, buff=0)\n        sq_b = Square(side_length=4, color=BLUE, fill_opacity=0.2).next_to(Line(A, C), LEFT, buff=0)\n        sq_c = Square(side_length=5, color=GREEN, fill_opacity=0.2)\n        sq_c.move_to((B+C)/2).rotate(Line(B, C).get_angle()).shift(0.5*normalize(C-B))\n        la = MathTex('a^2=9', font_size=28, color=RED).move_to(sq_a)\n        lb = MathTex('b^2=16', font_size=28, color=BLUE).move_to(sq_b)\n        lc = MathTex('c^2=25', font_size=28, color=GREEN).move_to(sq_c)\n        group = VGroup(triangle, sq_a, sq_b, sq_c, la, lb, lc).move_to(ORIGIN).scale(0.7)\n        self.play(Create(triangle))\n        self.play(Create(sq_a), Write(la))\n        self.play(Create(sq_b), Write(lb))\n        self.play(Create(sq_c), Write(lc))\n        formula = MathTex('a^2 + b^2 = c^2', font_size=48).to_edge(UP)\n        self.play(Write(formula))\n        self.wait()"}
{"prompt": "Create an animated stopwatch counting seconds", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        circle = Circle(radius=2, color=WHITE)\n        center_dot = Dot(ORIGIN, color=WHITE, radius=0.06)\n        hand = Line(ORIGIN, UP*1.7, color=RED, stroke_width=3)\n        time_display = DecimalNumber(0, num_decimal_places=1, font_size=48, unit='s').shift(DOWN*2.8)\n        title = Text('Stopwatch', font_size=36).to_edge(UP)\n        self.play(Create(circle), Create(center_dot), Write(title))\n        self.add(hand, time_display)\n        self.play(\n            Rotate(hand, -TAU, about_point=ORIGIN),\n            ChangeDecimalToValue(time_display, 60),\n            run_time=5, rate_func=linear\n        )\n        self.wait()"}
{"prompt": "Display the binomial theorem formula", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Binomial Theorem', font_size=48).to_edge(UP)\n        formula = MathTex(\n            '(a+b)^n = \\\\sum_{k=0}^{n} \\\\binom{n}{k} a^{n-k} b^k',\n            font_size=48\n        )\n        example = MathTex(\n            '(a+b)^2 = a^2 + 2ab + b^2',\n            font_size=42\n        ).shift(DOWN*1.5)\n        self.play(Write(title))\n        self.play(Write(formula))\n        self.wait(0.5)\n        self.play(Write(example))\n        self.wait()"}
{"prompt": "Create a radar chart with 5 axes", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        n = 5\n        labels = ['Speed', 'Power', 'Skill', 'Defense', 'Stamina']\n        values = [0.8, 0.6, 0.9, 0.5, 0.7]\n        axes_group = VGroup()\n        for i in range(n):\n            angle = PI/2 - i*TAU/n\n            line = Line(ORIGIN, 2.5*np.array([np.cos(angle), np.sin(angle), 0]), color=GRAY)\n            label = Text(labels[i], font_size=20).move_to(3*np.array([np.cos(angle), np.sin(angle), 0]))\n            axes_group.add(line, label)\n        points = [values[i]*2.5*np.array([np.cos(PI/2 - i*TAU/n), np.sin(PI/2 - i*TAU/n), 0]) for i in range(n)]\n        polygon = Polygon(*points, color=BLUE, fill_opacity=0.3, stroke_width=2)\n        dots = VGroup(*[Dot(p, color=BLUE, radius=0.08) for p in points])\n        self.play(Create(axes_group))\n        self.play(Create(polygon), Create(dots))\n        self.wait()"}
{"prompt": "Show Ohm's law V=IR with a circuit diagram", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text(\"Ohm's Law\", font_size=48).to_edge(UP)\n        formula = MathTex('V = I \\\\cdot R', font_size=72)\n        formula[0][0].set_color(RED)\n        formula[0][2].set_color(BLUE)\n        formula[0][4].set_color(GREEN)\n        desc = VGroup(\n            Text('V = Voltage (Volts)', font_size=28, color=RED),\n            Text('I = Current (Amperes)', font_size=28, color=BLUE),\n            Text('R = Resistance (Ohms)', font_size=28, color=GREEN),\n        ).arrange(DOWN, aligned_edge=LEFT).shift(DOWN*2)\n        self.play(Write(title))\n        self.play(Write(formula))\n        self.play(FadeIn(desc))\n        self.wait()"}
{"prompt": "Animate drawing a star shape", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        star = Star(n=5, outer_radius=2.5, inner_radius=1, color=YELLOW, fill_opacity=0.5)\n        self.play(Create(star), run_time=2)\n        self.play(star.animate.set_fill(GOLD, opacity=0.8), run_time=1)\n        self.play(Rotate(star, TAU), run_time=2)\n        self.wait()"}
{"prompt": "Create a comparison of O(1), O(n), O(n^2) complexity", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Big-O Complexity', font_size=40).to_edge(UP)\n        axes = Axes(x_range=[0, 6, 1], y_range=[0, 30, 5], axis_config={'include_numbers': True}).scale(0.7).shift(DOWN*0.3)\n        o1 = axes.plot(lambda x: 1, x_range=[0.1, 6], color=GREEN)\n        on = axes.plot(lambda x: x, x_range=[0, 6], color=BLUE)\n        on2 = axes.plot(lambda x: x**2, x_range=[0, 5.5], color=RED)\n        l1 = Text('O(1)', font_size=22, color=GREEN).move_to(axes.c2p(5.5, 2.5))\n        l2 = Text('O(n)', font_size=22, color=BLUE).move_to(axes.c2p(5.5, 7))\n        l3 = Text('O(n^2)', font_size=22, color=RED).move_to(axes.c2p(4, 22))\n        self.play(Write(title), Create(axes))\n        self.play(Create(o1), Write(l1))\n        self.play(Create(on), Write(l2))\n        self.play(Create(on2), Write(l3))\n        self.wait()"}
{"prompt": "Show the unit circle with sin and cos labeled", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        axes = Axes(x_range=[-1.5, 1.5, 0.5], y_range=[-1.5, 1.5, 0.5])\n        circle = Circle(radius=1, color=WHITE).move_to(axes.c2p(0, 0))\n        angle = PI/4\n        point = np.array([np.cos(angle), np.sin(angle), 0])\n        radius_line = Line(axes.c2p(0, 0), axes.c2p(*point), color=YELLOW)\n        dot = Dot(axes.c2p(*point), color=YELLOW)\n        cos_line = Line(axes.c2p(0, 0), axes.c2p(np.cos(angle), 0, 0), color=RED, stroke_width=4)\n        sin_line = Line(axes.c2p(np.cos(angle), 0, 0), axes.c2p(*point), color=BLUE, stroke_width=4)\n        cos_label = MathTex('\\\\cos\\\\theta', font_size=28, color=RED).next_to(cos_line, DOWN)\n        sin_label = MathTex('\\\\sin\\\\theta', font_size=28, color=BLUE).next_to(sin_line, RIGHT)\n        angle_arc = Angle(Line(ORIGIN, RIGHT), radius_line, radius=0.4, color=GREEN)\n        theta = MathTex('\\\\theta', font_size=24, color=GREEN).move_to(0.6*np.array([np.cos(angle/2), np.sin(angle/2), 0]))\n        self.play(Create(axes), Create(circle))\n        self.play(Create(radius_line), Create(dot))\n        self.play(Create(cos_line), Write(cos_label))\n        self.play(Create(sin_line), Write(sin_label))\n        self.play(Create(angle_arc), Write(theta))\n        self.wait()"}
{"prompt": "Create a visual proof that the sum of angles in a triangle is 180 degrees", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        A = LEFT*2.5 + DOWN*1\n        B = RIGHT*2.5 + DOWN*1\n        C = UP*1.5\n        triangle = Polygon(A, B, C, color=WHITE)\n        alpha = Angle(Line(A, B), Line(A, C), radius=0.5, color=RED)\n        beta = Angle(Line(B, C), Line(B, A), radius=0.5, color=BLUE)\n        gamma = Angle(Line(C, A), Line(C, B), radius=0.5, color=GREEN)\n        la = MathTex('\\\\alpha', font_size=24, color=RED).next_to(alpha, UP*0.5+RIGHT*0.5)\n        lb = MathTex('\\\\beta', font_size=24, color=BLUE).next_to(beta, UP*0.5+LEFT*0.5)\n        lg = MathTex('\\\\gamma', font_size=24, color=GREEN).next_to(gamma, DOWN*0.5)\n        formula = MathTex('\\\\alpha + \\\\beta + \\\\gamma = 180^\\\\circ', font_size=48).to_edge(UP)\n        self.play(Create(triangle))\n        self.play(Create(alpha), Write(la))\n        self.play(Create(beta), Write(lb))\n        self.play(Create(gamma), Write(lg))\n        self.play(Write(formula))\n        self.play(Indicate(formula))\n        self.wait()"}
{"prompt": "Animate a number doubling repeatedly to show exponential growth", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Exponential Growth: Doubling', font_size=36).to_edge(UP)\n        self.play(Write(title))\n        values = [1, 2, 4, 8, 16, 32, 64, 128]\n        prev_text = None\n        for i, val in enumerate(values):\n            text = Text(str(val), font_size=72, color=YELLOW)\n            if i > 0:\n                mult = MathTex(f'\\\\times 2 = {val}', font_size=48).shift(DOWN)\n                self.play(ReplacementTransform(prev_text, text), FadeIn(mult, shift=UP), run_time=0.5)\n                self.wait(0.3)\n                self.play(FadeOut(mult), run_time=0.2)\n            else:\n                self.play(Write(text))\n                self.wait(0.3)\n            prev_text = text\n        self.wait()"}
{"prompt": "Show the area of a circle derivation", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Area of a Circle', font_size=42).to_edge(UP)\n        circle = Circle(radius=2, color=BLUE, fill_opacity=0.3)\n        radius = Line(ORIGIN, RIGHT*2, color=RED)\n        r_label = MathTex('r', font_size=36, color=RED).next_to(radius, DOWN, buff=0.1)\n        self.play(Write(title))\n        self.play(Create(circle))\n        self.play(Create(radius), Write(r_label))\n        formula = MathTex('A = \\\\pi r^2', font_size=64).shift(DOWN*2.5)\n        self.play(Write(formula))\n        self.play(Indicate(formula))\n        self.wait()"}
{"prompt": "Create an animated Conway's Game of Life grid", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        size = 10\n        grid = np.zeros((size, size), dtype=int)\n        glider = [(0,1),(1,2),(2,0),(2,1),(2,2)]\n        for r,c in glider:\n            grid[r+2][c+2] = 1\n        def draw_grid(g):\n            cells = VGroup()\n            for r in range(size):\n                for c in range(size):\n                    sq = Square(side_length=0.5, stroke_width=0.5, color=GRAY)\n                    sq.move_to(RIGHT*(c*0.5 - 2.25) + UP*(r*0.5 - 2.25))\n                    if g[r][c]:\n                        sq.set_fill(GREEN, opacity=0.8)\n                    cells.add(sq)\n            return cells\n        def step(g):\n            new = np.zeros_like(g)\n            for r in range(size):\n                for c in range(size):\n                    n = sum(g[(r+dr)%size][(c+dc)%size] for dr in [-1,0,1] for dc in [-1,0,1] if not (dr==0 and dc==0))\n                    if g[r][c] and n in [2,3]: new[r][c] = 1\n                    elif not g[r][c] and n == 3: new[r][c] = 1\n            return new\n        cells = draw_grid(grid)\n        self.play(Create(cells), run_time=1)\n        for _ in range(8):\n            grid = step(grid)\n            new_cells = draw_grid(grid)\n            self.play(Transform(cells, new_cells), run_time=0.4)\n        self.wait()"}
{"prompt": "Show Gauss's formula for sum of first n numbers", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Sum of First n Numbers', font_size=42).to_edge(UP)\n        step1 = MathTex('1 + 2 + 3 + \\\\cdots + n', font_size=48)\n        step2 = MathTex('= \\\\frac{n(n+1)}{2}', font_size=56)\n        example = MathTex('1+2+3+\\\\cdots+100 = \\\\frac{100 \\\\times 101}{2} = 5050', font_size=36)\n        self.play(Write(title))\n        self.play(Write(step1))\n        self.play(step1.animate.shift(UP*0.5))\n        step2.next_to(step1, DOWN, buff=0.5)\n        self.play(Write(step2))\n        example.shift(DOWN*1.5)\n        self.play(Write(example))\n        self.play(Indicate(example))\n        self.wait()"}
{"prompt": "Create a DNA base pair visualization showing A-T and G-C", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('DNA Base Pairs', font_size=42).to_edge(UP)\n        pairs = [('A', 'T', RED, BLUE), ('T', 'A', BLUE, RED), ('G', 'C', GREEN, YELLOW), ('C', 'G', YELLOW, GREEN)]\n        group = VGroup()\n        for i, (left, right, lc, rc) in enumerate(pairs):\n            y = 1.5 - i*1.2\n            lb = Circle(radius=0.35, color=lc, fill_opacity=0.7).move_to(LEFT*2 + UP*y)\n            rb = Circle(radius=0.35, color=rc, fill_opacity=0.7).move_to(RIGHT*2 + UP*y)\n            lt = Text(left, font_size=28, color=WHITE).move_to(lb)\n            rt = Text(right, font_size=28, color=WHITE).move_to(rb)\n            bond = DashedLine(lb.get_right(), rb.get_left(), color=WHITE, dash_length=0.1)\n            group.add(VGroup(lb, lt, rb, rt, bond))\n        self.play(Write(title))\n        for g in group:\n            self.play(Create(g), run_time=0.5)\n        self.wait()"}
{"prompt": "Animate a gear rotating", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        teeth = 12\n        outer_r = 2\n        inner_r = 1.5\n        points = []\n        for i in range(teeth):\n            angle1 = i * TAU / teeth\n            angle2 = (i + 0.3) * TAU / teeth\n            angle3 = (i + 0.5) * TAU / teeth\n            angle4 = (i + 0.8) * TAU / teeth\n            points.extend([\n                inner_r * np.array([np.cos(angle1), np.sin(angle1), 0]),\n                outer_r * np.array([np.cos(angle2), np.sin(angle2), 0]),\n                outer_r * np.array([np.cos(angle3), np.sin(angle3), 0]),\n                inner_r * np.array([np.cos(angle4), np.sin(angle4), 0]),\n            ])\n        gear = Polygon(*points, color=GRAY, fill_opacity=0.5)\n        center = Circle(radius=0.3, color=DARK_GRAY, fill_opacity=1)\n        gear_group = VGroup(gear, center)\n        self.play(Create(gear_group))\n        self.play(Rotate(gear_group, TAU, run_time=3, rate_func=linear))\n        self.wait()"}
{"prompt": "Show a Fourier series approximation of a square wave", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        axes = Axes(x_range=[-4, 4, 1], y_range=[-1.5, 1.5, 0.5])\n        title = Text('Fourier Series: Square Wave', font_size=32).to_edge(UP)\n        self.play(Create(axes), Write(title))\n        colors = [BLUE, GREEN, YELLOW, RED, PURPLE]\n        for n_terms in [1, 3, 5, 7, 15]:\n            def make_fourier(n=n_terms):\n                def f(x):\n                    s = 0\n                    for k in range(1, n+1, 2):\n                        s += (4/(k*PI)) * np.sin(k*x)\n                    return s\n                return f\n            color = colors[min([1,3,5,7,15].index(n_terms), len(colors)-1)]\n            curve = axes.plot(make_fourier(), x_range=[-4, 4], color=color)\n            label = Text(f'n={n_terms}', font_size=24, color=color).to_corner(UR).shift(DOWN*[1,3,5,7,15].index(n_terms)*0.4)\n            self.play(Create(curve), Write(label), run_time=0.8)\n        self.wait()"}
{"prompt": "Create an animated water droplet falling and splashing", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        drop = Dot(radius=0.15, color=BLUE).shift(UP*3)\n        surface = Line(LEFT*5, RIGHT*5, color=BLUE_B).shift(DOWN*2)\n        self.add(surface)\n        self.play(Create(drop))\n        self.play(drop.animate.move_to(DOWN*2), run_time=0.8, rate_func=rush_into)\n        splash_dots = VGroup()\n        for angle in [PI/6, PI/3, PI/2, 2*PI/3, 5*PI/6]:\n            d = Dot(radius=0.06, color=BLUE_A).move_to(DOWN*2)\n            target = DOWN*2 + 1.5*np.array([np.cos(angle), np.sin(angle), 0])\n            splash_dots.add(d)\n        self.play(\n            FadeOut(drop),\n            *[d.animate.move_to(DOWN*2 + 1.5*np.array([np.cos(a), np.sin(a), 0])) for d, a in zip(splash_dots, [PI/6, PI/3, PI/2, 2*PI/3, 5*PI/6])],\n            run_time=0.5\n        )\n        self.play(FadeOut(splash_dots), run_time=0.5)\n        self.wait()"}
{"prompt": "Show the periodic table element for Hydrogen", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        box = Square(side_length=3, color=WHITE)\n        atomic_num = Text('1', font_size=28).move_to(box.get_corner(UL) + DR*0.4)\n        symbol = Text('H', font_size=72, weight=BOLD).move_to(box)\n        name = Text('Hydrogen', font_size=24).next_to(symbol, DOWN, buff=0.2)\n        mass = Text('1.008', font_size=20, color=GRAY).next_to(name, DOWN, buff=0.15)\n        self.play(Create(box), Write(atomic_num))\n        self.play(Write(symbol))\n        self.play(Write(name), Write(mass))\n        self.wait()"}
{"prompt": "Create a color mixing demonstration red + blue = purple", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        c_red = Circle(radius=1, color=RED, fill_opacity=0.7).shift(LEFT*2)\n        c_blue = Circle(radius=1, color=BLUE, fill_opacity=0.7).shift(RIGHT*2)\n        plus = MathTex('+', font_size=48)\n        equals = MathTex('=', font_size=48).shift(RIGHT*4.5)\n        c_purple = Circle(radius=1, color=PURPLE, fill_opacity=0.7).shift(RIGHT*6.5)\n        self.play(Create(c_red))\n        self.play(Write(plus))\n        self.play(Create(c_blue))\n        self.play(Write(equals), Create(c_purple))\n        self.wait()"}
{"prompt": "Animate a growing plant with stem and leaves", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        ground = Line(LEFT*5, RIGHT*5, color=DARK_BROWN).shift(DOWN*3)\n        stem = Line(DOWN*3, UP*1, color=GREEN, stroke_width=4)\n        leaf1 = Ellipse(width=1.2, height=0.5, color=GREEN, fill_opacity=0.7).move_to(LEFT*0.6 + DOWN*0.5).rotate(PI/6)\n        leaf2 = Ellipse(width=1.2, height=0.5, color=GREEN, fill_opacity=0.7).move_to(RIGHT*0.6 + UP*0.2).rotate(-PI/6)\n        flower = VGroup(\n            *[Ellipse(width=0.6, height=0.3, color=PINK, fill_opacity=0.8).move_to(UP*1).rotate(i*TAU/5).shift(0.4*np.array([np.cos(i*TAU/5), np.sin(i*TAU/5), 0])) for i in range(5)],\n            Circle(radius=0.25, color=YELLOW, fill_opacity=1).move_to(UP*1)\n        )\n        self.add(ground)\n        self.play(Create(stem), run_time=1.5)\n        self.play(GrowFromCenter(leaf1), GrowFromCenter(leaf2))\n        self.play(GrowFromCenter(flower))\n        self.wait()"}
{"prompt": "Show the difference between mean, median, and mode", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Mean, Median, Mode', font_size=42).to_edge(UP)\n        data = Text('Data: [2, 3, 3, 5, 7, 8, 8, 8, 10]', font_size=28).shift(UP*1.5)\n        mean_t = MathTex('\\\\text{Mean} = \\\\frac{2+3+3+5+7+8+8+8+10}{9} = 6', font_size=32, color=RED)\n        median_t = Text('Median = 7 (middle value)', font_size=28, color=BLUE)\n        mode_t = Text('Mode = 8 (most frequent)', font_size=28, color=GREEN)\n        stats = VGroup(mean_t, median_t, mode_t).arrange(DOWN, buff=0.6).shift(DOWN*0.8)\n        self.play(Write(title))\n        self.play(Write(data))\n        for stat in stats:\n            self.play(Write(stat))\n        self.wait()"}
{"prompt": "Create a visual representation of a queue data structure", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Queue (FIFO)', font_size=36).to_edge(UP)\n        self.play(Write(title))\n        queue = VGroup()\n        colors = [RED, ORANGE, YELLOW, GREEN, BLUE]\n        for i in range(5):\n            box = Rectangle(width=1.2, height=0.8, color=colors[i], fill_opacity=0.5)\n            num = Text(str(i+1), font_size=28).move_to(box)\n            item = VGroup(box, num).move_to(RIGHT*(i*1.4 - 2.8))\n            enqueue = Text('enqueue', font_size=20, color=GREEN).to_edge(LEFT).shift(DOWN*2)\n            self.play(FadeIn(item, shift=LEFT), run_time=0.4)\n            queue.add(item)\n        dequeue = Text('dequeue', font_size=20, color=RED).to_edge(RIGHT).shift(DOWN*2)\n        self.play(Write(dequeue))\n        self.play(FadeOut(queue[0], shift=RIGHT), run_time=0.5)\n        self.play(FadeOut(dequeue))\n        self.wait()"}
{"prompt": "Animate a compass needle pointing north", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        outer = Circle(radius=2.5, color=WHITE)\n        inner = Circle(radius=0.1, color=WHITE, fill_opacity=1)\n        n_label = Text('N', font_size=28, color=RED).move_to(UP*2.8)\n        s_label = Text('S', font_size=28).move_to(DOWN*2.8)\n        e_label = Text('E', font_size=28).move_to(RIGHT*2.8)\n        w_label = Text('W', font_size=28).move_to(LEFT*2.8)\n        needle_n = Line(ORIGIN, UP*1.8, color=RED, stroke_width=5)\n        needle_s = Line(ORIGIN, DOWN*1.8, color=WHITE, stroke_width=5)\n        needle = VGroup(needle_n, needle_s)\n        needle.rotate(PI/3)\n        self.play(Create(outer), Write(n_label), Write(s_label), Write(e_label), Write(w_label), Create(inner))\n        self.add(needle)\n        self.play(Rotate(needle, -PI/3, about_point=ORIGIN), run_time=2, rate_func=there_and_back_with_pause)\n        self.wait()"}
{"prompt": "Show the water cycle with labeled stages", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Water Cycle', font_size=42).to_edge(UP)\n        ocean = Rectangle(width=12, height=1.5, fill_color=BLUE, fill_opacity=0.5).shift(DOWN*2.5)\n        cloud = Ellipse(width=3, height=1.5, fill_color=GRAY, fill_opacity=0.7).shift(UP*2 + RIGHT*2)\n        sun = Circle(radius=0.8, color=YELLOW, fill_opacity=0.8).shift(UP*2 + LEFT*3)\n        evap_arrow = Arrow(DOWN*1.7 + LEFT, UP*1 + RIGHT, color=RED, buff=0.2)\n        cond_label = Text('Condensation', font_size=20, color=GRAY).next_to(cloud, UP, buff=0.1)\n        evap_label = Text('Evaporation', font_size=20, color=RED).next_to(evap_arrow, LEFT, buff=0.1)\n        precip_arrow = Arrow(UP*1.2 + RIGHT*3, DOWN*1.5 + RIGHT*3, color=BLUE, buff=0.2)\n        precip_label = Text('Precipitation', font_size=20, color=BLUE).next_to(precip_arrow, RIGHT, buff=0.1)\n        self.play(Write(title))\n        self.play(FadeIn(ocean), Create(sun))\n        self.play(GrowArrow(evap_arrow), Write(evap_label))\n        self.play(FadeIn(cloud), Write(cond_label))\n        self.play(GrowArrow(precip_arrow), Write(precip_label))\n        self.wait()"}
{"prompt": "Create a pixelated smiley face using squares", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        pixel_size = 0.4\n        pixels = [\n            (3,1),(4,1),(5,1),(6,1),(7,1),(8,1),\n            (2,2),(9,2),\n            (1,3),(3,3),(4,3),(7,3),(8,3),(10,3),\n            (1,4),(3,4),(4,4),(7,4),(8,4),(10,4),\n            (1,5),(10,5),\n            (1,6),(3,6),(8,6),(10,6),\n            (2,7),(4,7),(5,7),(6,7),(7,7),(9,7),\n            (3,8),(4,8),(5,8),(6,8),(7,8),(8,8),\n        ]\n        face = VGroup()\n        for x, y in pixels:\n            sq = Square(side_length=pixel_size, color=YELLOW, fill_opacity=0.8, stroke_width=0.5)\n            sq.move_to(RIGHT*(x*pixel_size - 2.2) + UP*(y*pixel_size - 1.6))\n            face.add(sq)\n        self.play(LaggedStart(*[FadeIn(p, scale=0.5) for p in face], lag_ratio=0.03))\n        self.wait()"}
{"prompt": "Show the chain rule visually with nested functions", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Chain Rule', font_size=48).to_edge(UP)\n        f_box = Rectangle(width=3, height=1.5, color=BLUE, fill_opacity=0.2).shift(RIGHT*2)\n        g_box = Rectangle(width=3, height=1.5, color=RED, fill_opacity=0.2).shift(LEFT*2)\n        f_label = MathTex('f', font_size=48, color=BLUE).move_to(f_box)\n        g_label = MathTex('g', font_size=48, color=RED).move_to(g_box)\n        arrow = Arrow(g_box.get_right(), f_box.get_left(), buff=0.1)\n        x_in = MathTex('x', font_size=36).next_to(g_box, LEFT, buff=0.5)\n        out = MathTex('f(g(x))', font_size=36).next_to(f_box, RIGHT, buff=0.5)\n        rule = MathTex('\\\\frac{d}{dx}f(g(x)) = f\\'(g(x)) \\\\cdot g\\'(x)', font_size=42).shift(DOWN*2)\n        self.play(Write(title))\n        self.play(Create(g_box), Write(g_label), Write(x_in))\n        self.play(GrowArrow(arrow))\n        self.play(Create(f_box), Write(f_label), Write(out))\n        self.play(Write(rule))\n        self.play(Indicate(rule))\n        self.wait()"}
{"prompt": "Animate a maze being solved with a path", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        walls = VGroup()\n        size = 0.5\n        maze_walls = [\n            (0,0,5,0),(0,0,0,5),(5,0,5,5),(0,5,5,5),\n            (1,0,1,3),(2,1,2,4),(3,0,3,2),(3,3,3,5),(4,1,4,4),\n        ]\n        for x1,y1,x2,y2 in maze_walls:\n            wall = Line(\n                [x1*size-1.25, y1*size-1.25, 0],\n                [x2*size-1.25, y2*size-1.25, 0],\n                color=WHITE, stroke_width=2\n            )\n            walls.add(wall)\n        path_points = [(0.5,0.25),(0.5,2.75),(1.5,2.75),(1.5,0.5),(2.5,0.5),(2.5,2.5),(2.5,4.5),(3.5,4.5),(3.5,2.5),(4.5,2.5),(4.5,4.75)]\n        path = VMobject(color=GREEN, stroke_width=4)\n        path.set_points_as_corners([np.array([x*size-1.25, y*size-1.25, 0]) for x,y in path_points])\n        start = Dot([0.5*size-1.25, 0.25*size-1.25, 0], color=BLUE, radius=0.1)\n        end = Dot([4.5*size-1.25, 4.75*size-1.25, 0], color=RED, radius=0.1)\n        VGroup(walls, path, start, end).scale(1.8).move_to(ORIGIN)\n        self.play(Create(walls))\n        self.play(Create(start), Create(end))\n        self.play(Create(path), run_time=3)\n        self.wait()"}
{"prompt": "Create animated rain falling", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        np.random.seed(42)\n        drops = VGroup()\n        for _ in range(40):\n            x = np.random.uniform(-6, 6)\n            y = np.random.uniform(0, 8)\n            drop = Line(ORIGIN, DOWN*0.3, color=BLUE_B, stroke_width=1.5).shift(UP*y + RIGHT*x)\n            drops.add(drop)\n        self.add(drops)\n        self.play(drops.animate.shift(DOWN*10), run_time=3, rate_func=linear)\n        self.wait()"}
{"prompt": "Show how a derivative relates to slope of a tangent line", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        axes = Axes(x_range=[-1, 5, 1], y_range=[-1, 10, 2])\n        curve = axes.plot(lambda x: 0.5*x**2, color=BLUE)\n        x_val = ValueTracker(2)\n        dot = always_redraw(lambda: Dot(axes.c2p(x_val.get_value(), 0.5*x_val.get_value()**2), color=YELLOW))\n        tangent = always_redraw(lambda: axes.get_secant_slope_group(\n            x=x_val.get_value(), graph=curve, dx=0.01,\n            secant_line_length=4, secant_line_color=RED\n        ))\n        slope_label = always_redraw(lambda: MathTex(\n            f'm = {x_val.get_value():.1f}', font_size=32, color=RED\n        ).to_corner(UR))\n        self.play(Create(axes), Create(curve))\n        self.add(dot, tangent, slope_label)\n        self.play(x_val.animate.set_value(4), run_time=4)\n        self.play(x_val.animate.set_value(0.5), run_time=3)\n        self.wait()"}
{"prompt": "Display a molecular structure of water H2O", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Water Molecule (H2O)', font_size=36).to_edge(UP)\n        oxygen = Circle(radius=0.5, color=RED, fill_opacity=0.8)\n        o_label = Text('O', font_size=28, color=WHITE).move_to(oxygen)\n        h1 = Circle(radius=0.35, color=BLUE, fill_opacity=0.8).shift(LEFT*1.5 + DOWN*0.8)\n        h1_label = Text('H', font_size=24, color=WHITE).move_to(h1)\n        h2 = Circle(radius=0.35, color=BLUE, fill_opacity=0.8).shift(RIGHT*1.5 + DOWN*0.8)\n        h2_label = Text('H', font_size=24, color=WHITE).move_to(h2)\n        bond1 = Line(oxygen.get_center(), h1.get_center(), color=WHITE, stroke_width=4)\n        bond2 = Line(oxygen.get_center(), h2.get_center(), color=WHITE, stroke_width=4)\n        angle_arc = Angle(Line(ORIGIN, h1.get_center()), Line(ORIGIN, h2.get_center()), radius=0.6, color=YELLOW)\n        angle_label = MathTex('104.5^\\\\circ', font_size=24, color=YELLOW).shift(DOWN*0.5)\n        molecule = VGroup(bond1, bond2, oxygen, o_label, h1, h1_label, h2, h2_label, angle_arc, angle_label)\n        self.play(Write(title))\n        self.play(Create(molecule), run_time=2)\n        self.wait()"}
{"prompt": "Animate a typewriter printing a paragraph", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        lines = [\n            'The quick brown fox',\n            'jumps over the lazy dog.',\n            'Pack my box with five',\n            'dozen liquor jugs.'\n        ]\n        text_group = VGroup()\n        for i, line in enumerate(lines):\n            t = Text(line, font_size=32, font='Courier New')\n            t.move_to(UP*(1.5 - i*0.8) + LEFT*0.5)\n            text_group.add(t)\n        for line_text in text_group:\n            self.play(Write(line_text), run_time=1)\n        self.wait()"}
{"prompt": "Create a 3D sphere with latitude and longitude lines", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(ThreeDScene):\n    def construct(self):\n        self.set_camera_orientation(phi=70*DEGREES, theta=30*DEGREES)\n        sphere = Sphere(radius=2, resolution=(20, 20)).set_opacity(0.3).set_color(BLUE)\n        lat_lines = VGroup()\n        for angle in range(-60, 90, 30):\n            lat = ParametricFunction(\n                lambda t, a=angle: np.array([2*np.cos(a*DEGREES)*np.cos(t), 2*np.cos(a*DEGREES)*np.sin(t), 2*np.sin(a*DEGREES)]),\n                t_range=[0, TAU], color=YELLOW, stroke_width=1\n            )\n            lat_lines.add(lat)\n        lon_lines = VGroup()\n        for angle in range(0, 180, 30):\n            lon = ParametricFunction(\n                lambda t, a=angle: np.array([2*np.sin(t)*np.cos(a*DEGREES), 2*np.sin(t)*np.sin(a*DEGREES), 2*np.cos(t)]),\n                t_range=[0, TAU], color=GREEN, stroke_width=1\n            )\n            lon_lines.add(lon)\n        self.play(Create(sphere), Create(lat_lines), Create(lon_lines), run_time=2)\n        self.begin_ambient_camera_rotation(rate=0.3)\n        self.wait(4)"}
{"prompt": "Show probability distribution of rolling two dice", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Sum of Two Dice', font_size=36).to_edge(UP)\n        probs = {2:1, 3:2, 4:3, 5:4, 6:5, 7:6, 8:5, 9:4, 10:3, 11:2, 12:1}\n        bars = VGroup()\n        labels = VGroup()\n        for i, (val, count) in enumerate(probs.items()):\n            height = count * 0.4\n            bar = Rectangle(width=0.6, height=height, fill_color=BLUE, fill_opacity=0.7, color=WHITE)\n            bar.move_to(RIGHT*(i*0.75 - 3.75) + UP*(height/2 - 2))\n            label = Text(str(val), font_size=18).next_to(bar, DOWN, buff=0.1)\n            prob = Text(f'{count}/36', font_size=14).next_to(bar, UP, buff=0.05)\n            bars.add(bar)\n            labels.add(label, prob)\n        self.play(Write(title))\n        self.play(LaggedStart(*[GrowFromEdge(b, DOWN) for b in bars], lag_ratio=0.1))\n        self.play(Write(labels))\n        self.wait()"}
{"prompt": "Animate a Rubik's cube face rotation in 2D", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        colors = [RED, GREEN, BLUE, ORANGE, WHITE, YELLOW, RED, GREEN, BLUE]\n        face = VGroup()\n        for i in range(3):\n            for j in range(3):\n                sq = Square(side_length=0.9, color=BLACK, fill_color=colors[i*3+j], fill_opacity=0.9, stroke_width=2)\n                sq.move_to(RIGHT*(j-1) + UP*(1-i))\n                face.add(sq)\n        title = Text(\"Rubik's Cube Face\", font_size=36).to_edge(UP)\n        self.play(Write(title))\n        self.play(Create(face))\n        top_row = VGroup(face[0], face[1], face[2])\n        self.play(Indicate(top_row))\n        positions = [face[2].get_center(), face[0].get_center(), face[1].get_center()]\n        self.play(\n            face[0].animate.move_to(face[2].get_center()),\n            face[2].animate.move_to(face[1].get_center()),\n            face[1].animate.move_to(face[0].get_center()),\n            run_time=1\n        )\n        self.wait()"}
{"prompt": "Show integration by parts formula with example", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Integration by Parts', font_size=42).to_edge(UP)\n        formula = MathTex(\n            '\\\\int u \\\\, dv = uv - \\\\int v \\\\, du',\n            font_size=56\n        )\n        example_title = Text('Example:', font_size=28, color=YELLOW).shift(DOWN*0.8 + LEFT*3)\n        example = MathTex(\n            '\\\\int x \\\\, e^x \\\\, dx = x \\\\, e^x - e^x + C',\n            font_size=40\n        ).shift(DOWN*1.8)\n        self.play(Write(title))\n        self.play(Write(formula))\n        self.play(formula.animate.shift(UP*0.5))\n        self.play(Write(example_title))\n        self.play(Write(example))\n        self.wait()"}
{"prompt": "Create animated fireworks exploding", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        self.camera.background_color = BLACK\n        for burst_pos in [LEFT*2 + UP*1, RIGHT*2 + UP*2, UP*0.5]:\n            rocket = Dot(DOWN*3, color=YELLOW, radius=0.08)\n            self.play(rocket.animate.move_to(burst_pos), run_time=0.5, rate_func=rush_into)\n            particles = VGroup()\n            color = np.random.choice([RED, GOLD, BLUE, GREEN, PINK])\n            for angle in np.linspace(0, TAU, 16, endpoint=False):\n                p = Dot(burst_pos, color=color, radius=0.05)\n                particles.add(p)\n            targets = [burst_pos + 1.5*np.array([np.cos(a), np.sin(a), 0]) for a in np.linspace(0, TAU, 16, endpoint=False)]\n            self.play(\n                FadeOut(rocket),\n                *[p.animate.move_to(t).set_opacity(0) for p, t in zip(particles, targets)],\n                run_time=1\n            )\n        self.wait()"}
{"prompt": "Show Pascal's triangle with 5 rows", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text(\"Pascal's Triangle\", font_size=42).to_edge(UP)\n        rows = [[1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1], [1,5,10,10,5,1]]\n        triangle = VGroup()\n        for r, row in enumerate(rows):\n            for c, val in enumerate(row):\n                x = (c - len(row)/2 + 0.5) * 1.2\n                y = 1.5 - r * 0.9\n                circle = Circle(radius=0.35, color=BLUE, fill_opacity=0.2).move_to([x, y, 0])\n                num = Text(str(val), font_size=24).move_to(circle)\n                triangle.add(VGroup(circle, num))\n        self.play(Write(title))\n        self.play(LaggedStart(*[Create(t) for t in triangle], lag_ratio=0.05))\n        self.wait()"}
{"prompt": "Animate a simple solar system with orbiting planets", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        sun = Dot(ORIGIN, color=YELLOW, radius=0.3)\n        sun_label = Text('Sun', font_size=18, color=YELLOW).next_to(sun, DOWN, buff=0.4)\n        orbits = VGroup()\n        planets = []\n        planet_data = [(1.2, BLUE, 0.1, 'Mercury'), (1.8, ORANGE, 0.12, 'Venus'), (2.5, GREEN, 0.13, 'Earth'), (3.2, RED, 0.11, 'Mars')]\n        for radius, color, size, name in planet_data:\n            orbit = Circle(radius=radius, color=GRAY, stroke_width=0.5)\n            orbits.add(orbit)\n            planet = Dot(color=color, radius=size).move_to(RIGHT*radius)\n            planets.append((planet, orbit))\n        self.play(Create(sun), Write(sun_label))\n        self.play(Create(orbits))\n        for planet, orbit in planets:\n            self.add(planet)\n        self.play(\n            *[MoveAlongPath(p, o, rate_func=linear) for p, o in planets],\n            run_time=4\n        )\n        self.wait()"}
{"prompt": "Create a visual dictionary entry for the word 'Algorithm'", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        word = Text('Algorithm', font_size=56, weight=BOLD).shift(UP*2)\n        pronunciation = Text('/al-guh-rith-uhm/', font_size=24, slant=ITALIC, color=GRAY).next_to(word, DOWN, buff=0.2)\n        pos = Text('noun', font_size=22, color=BLUE, slant=ITALIC).next_to(pronunciation, DOWN, buff=0.3).align_to(word, LEFT)\n        definition = Text(\n            'A step-by-step procedure for solving\\na problem or accomplishing a task.',\n            font_size=26, line_spacing=1.3\n        ).next_to(pos, DOWN, buff=0.3).align_to(word, LEFT)\n        line = Line(LEFT*4, RIGHT*4, color=GRAY, stroke_width=1).next_to(definition, DOWN, buff=0.4)\n        example = Text('\"The sorting algorithm runs in O(n log n) time.\"', font_size=22, slant=ITALIC, color=YELLOW).next_to(line, DOWN, buff=0.3)\n        self.play(Write(word))\n        self.play(FadeIn(pronunciation))\n        self.play(Write(pos), Write(definition))\n        self.play(Create(line), Write(example))\n        self.wait()"}
{"prompt": "Show the difference between permutations and combinations", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Permutations vs Combinations', font_size=36).to_edge(UP)\n        perm_title = Text('Permutation', font_size=28, color=RED).shift(UP*1.5 + LEFT*3)\n        perm_formula = MathTex('P(n,r) = \\\\frac{n!}{(n-r)!}', font_size=36, color=RED).next_to(perm_title, DOWN)\n        perm_desc = Text('Order matters', font_size=22).next_to(perm_formula, DOWN, buff=0.3)\n        perm_ex = Text('ABC, ACB, BAC...', font_size=20, color=GRAY).next_to(perm_desc, DOWN)\n        comb_title = Text('Combination', font_size=28, color=BLUE).shift(UP*1.5 + RIGHT*3)\n        comb_formula = MathTex('C(n,r) = \\\\frac{n!}{r!(n-r)!}', font_size=36, color=BLUE).next_to(comb_title, DOWN)\n        comb_desc = Text('Order does not matter', font_size=22).next_to(comb_formula, DOWN, buff=0.3)\n        comb_ex = Text('{A,B,C} only', font_size=20, color=GRAY).next_to(comb_desc, DOWN)\n        divider = Line(UP*1.5, DOWN*2, color=GRAY)\n        self.play(Write(title))\n        self.play(Write(perm_title), Write(comb_title), Create(divider))\n        self.play(Write(perm_formula), Write(comb_formula))\n        self.play(Write(perm_desc), Write(comb_desc))\n        self.play(Write(perm_ex), Write(comb_ex))\n        self.wait()"}
{"prompt": "Animate a sine wave becoming a cosine wave", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        axes = Axes(x_range=[-4, 4, 1], y_range=[-2, 2, 1])\n        sine = axes.plot(lambda x: np.sin(x), color=BLUE)\n        cosine = axes.plot(lambda x: np.cos(x), color=RED)\n        sin_label = MathTex('\\\\sin(x)', font_size=36, color=BLUE).to_corner(UR)\n        cos_label = MathTex('\\\\cos(x)', font_size=36, color=RED).to_corner(UR)\n        self.play(Create(axes))\n        self.play(Create(sine), Write(sin_label))\n        self.wait(0.5)\n        self.play(Transform(sine, cosine), Transform(sin_label, cos_label), run_time=2)\n        self.wait()"}
{"prompt": "Create a visual explanation of recursion with boxes", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Recursion: factorial(4)', font_size=36).to_edge(UP)\n        calls = [\n            ('factorial(4)', '4 * factorial(3)', BLUE),\n            ('factorial(3)', '3 * factorial(2)', GREEN),\n            ('factorial(2)', '2 * factorial(1)', YELLOW),\n            ('factorial(1)', 'return 1', RED),\n        ]\n        boxes = VGroup()\n        for i, (name, body, color) in enumerate(calls):\n            box = Rectangle(width=4-i*0.3, height=0.7, color=color, fill_opacity=0.2)\n            box.shift(DOWN*i*0.9 + RIGHT*i*0.3)\n            label = Text(f'{name} = {body}', font_size=20).move_to(box)\n            boxes.add(VGroup(box, label))\n        group = VGroup(title, *boxes).move_to(ORIGIN)\n        self.play(Write(title))\n        for box in boxes:\n            self.play(Create(box), run_time=0.5)\n        result = Text('= 4 * 3 * 2 * 1 = 24', font_size=36, color=GREEN).shift(DOWN*3)\n        self.play(Write(result))\n        self.wait()"}
{"prompt": "Show a morphing shape from triangle to square to pentagon to hexagon", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        shapes = [\n            (RegularPolygon(3, color=RED), 'Triangle'),\n            (RegularPolygon(4, color=BLUE), 'Square'),\n            (RegularPolygon(5, color=GREEN), 'Pentagon'),\n            (RegularPolygon(6, color=YELLOW), 'Hexagon'),\n            (Circle(color=PURPLE), 'Circle'),\n        ]\n        current_shape = shapes[0][0].copy().scale(2)\n        current_label = Text(shapes[0][1], font_size=36).shift(DOWN*2.5)\n        self.play(Create(current_shape), Write(current_label))\n        for shape, name in shapes[1:]:\n            new_shape = shape.copy().scale(2)\n            new_label = Text(name, font_size=36).shift(DOWN*2.5)\n            self.play(\n                Transform(current_shape, new_shape),\n                Transform(current_label, new_label),\n                run_time=1\n            )\n            self.wait(0.3)\n        self.wait()"}
{"prompt": "Create a simple animation of a car moving along a road", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        road = Rectangle(width=14, height=1, fill_color=DARK_GRAY, fill_opacity=0.8, stroke_width=0)\n        center_line = DashedLine(LEFT*7, RIGHT*7, color=YELLOW, dash_length=0.3)\n        body = Rectangle(width=2, height=0.6, fill_color=RED, fill_opacity=0.9, color=RED).shift(LEFT*5)\n        roof = Rectangle(width=1, height=0.4, fill_color=RED, fill_opacity=0.9, color=RED).shift(LEFT*5 + UP*0.5)\n        w1 = Circle(radius=0.2, color=WHITE, fill_opacity=0.8).shift(LEFT*5.5 + DOWN*0.3)\n        w2 = Circle(radius=0.2, color=WHITE, fill_opacity=0.8).shift(LEFT*4.5 + DOWN*0.3)\n        car = VGroup(body, roof, w1, w2)\n        self.add(road, center_line)\n        self.play(Create(car))\n        self.play(car.animate.shift(RIGHT*10), run_time=3, rate_func=smooth)\n        self.wait()"}
{"prompt": "Show probability with a coin toss tree diagram", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Coin Toss Probability', font_size=36).to_edge(UP)\n        root = Dot(LEFT*4 + UP*1, color=WHITE, radius=0.1)\n        h1 = Text('H', font_size=24, color=GREEN).move_to(LEFT*1.5 + UP*2.5)\n        t1 = Text('T', font_size=24, color=RED).move_to(LEFT*1.5 + DOWN*0.5)\n        a1 = Arrow(root.get_center(), h1.get_center(), buff=0.2, stroke_width=2)\n        a2 = Arrow(root.get_center(), t1.get_center(), buff=0.2, stroke_width=2)\n        p1 = Text('1/2', font_size=18).next_to(a1, UP, buff=0.05)\n        p2 = Text('1/2', font_size=18).next_to(a2, DOWN, buff=0.05)\n        hh = Text('HH', font_size=20, color=GREEN).move_to(RIGHT*2 + UP*3)\n        ht = Text('HT', font_size=20, color=YELLOW).move_to(RIGHT*2 + UP*1.5)\n        th = Text('TH', font_size=20, color=YELLOW).move_to(RIGHT*2 + DOWN*0)\n        tt = Text('TT', font_size=20, color=RED).move_to(RIGHT*2 + DOWN*1.5)\n        a3 = Arrow(h1.get_center(), hh.get_center(), buff=0.2, stroke_width=1.5)\n        a4 = Arrow(h1.get_center(), ht.get_center(), buff=0.2, stroke_width=1.5)\n        a5 = Arrow(t1.get_center(), th.get_center(), buff=0.2, stroke_width=1.5)\n        a6 = Arrow(t1.get_center(), tt.get_center(), buff=0.2, stroke_width=1.5)\n        self.play(Write(title))\n        self.play(Create(root))\n        self.play(GrowArrow(a1), GrowArrow(a2), Write(p1), Write(p2))\n        self.play(Write(h1), Write(t1))\n        self.play(GrowArrow(a3), GrowArrow(a4), GrowArrow(a5), GrowArrow(a6))\n        self.play(Write(hh), Write(ht), Write(th), Write(tt))\n        self.wait()"}
{"prompt": "Create a thermometer animation showing temperature rising", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        bulb = Circle(radius=0.4, color=RED, fill_opacity=0.3).shift(DOWN*2.5)\n        tube = Rectangle(width=0.4, height=4, color=WHITE, fill_opacity=0).shift(DOWN*0.3)\n        mercury = Rectangle(width=0.3, height=0.1, color=RED, fill_opacity=0.8).align_to(bulb, UP).shift(UP*0.1)\n        ticks = VGroup()\n        for i in range(5):\n            y = -2 + i * 1\n            tick = Line(LEFT*0.35, LEFT*0.55, color=WHITE).shift(UP*y)\n            label = Text(f'{i*25}', font_size=16).next_to(tick, LEFT, buff=0.1)\n            ticks.add(tick, label)\n        title = Text('Temperature', font_size=32).to_edge(UP)\n        self.play(Write(title), Create(bulb), Create(tube), Create(ticks))\n        self.add(mercury)\n        self.play(\n            mercury.animate.stretch_to_fit_height(3.5).align_to(bulb, DOWN).shift(UP*0.2),\n            bulb.animate.set_fill(RED, opacity=0.9),\n            run_time=3\n        )\n        self.wait()"}
{"prompt": "Animate a flag waving using sine waves", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        pole = Line(LEFT*4 + DOWN*2.5, LEFT*4 + UP*2.5, color=GRAY, stroke_width=4)\n        self.play(Create(pole))\n        t = ValueTracker(0)\n        flag = always_redraw(lambda: ParametricFunction(\n            lambda s: np.array([\n                s - 4,\n                0.3 * np.sin(2*s + t.get_value()) * s/3 + 1,\n                0\n            ]),\n            t_range=[0, 3],\n            color=RED,\n            stroke_width=6\n        ))\n        flag2 = always_redraw(lambda: ParametricFunction(\n            lambda s: np.array([\n                s - 4,\n                0.3 * np.sin(2*s + t.get_value()) * s/3 + 0.5,\n                0\n            ]),\n            t_range=[0, 3],\n            color=RED,\n            stroke_width=6\n        ))\n        self.add(flag, flag2)\n        self.play(t.animate.set_value(4*PI), run_time=4, rate_func=linear)\n        self.wait()"}
{"prompt": "Show the relationship between circumference and diameter of a circle", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        circle = Circle(radius=1.5, color=BLUE)\n        diameter = Line(LEFT*1.5, RIGHT*1.5, color=RED, stroke_width=3)\n        d_label = MathTex('d', font_size=36, color=RED).next_to(diameter, DOWN, buff=0.1)\n        self.play(Create(circle))\n        self.play(Create(diameter), Write(d_label))\n        circumference_line = Line(LEFT*1.5*PI + DOWN*2, RIGHT*1.5*PI + DOWN*2, color=BLUE, stroke_width=3)\n        c_label = MathTex('C = \\\\pi d', font_size=36, color=BLUE).next_to(circumference_line, DOWN)\n        self.play(Create(circumference_line), Write(c_label))\n        formula = MathTex('C = \\\\pi \\\\times d \\\\approx 3.14 \\\\times d', font_size=42).to_edge(UP)\n        self.play(Write(formula))\n        self.wait()"}
{"prompt": "Create a simple game score display with lives and points", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        score_label = Text('SCORE:', font_size=32, color=WHITE).to_corner(UL)\n        score = DecimalNumber(0, num_decimal_places=0, font_size=32, color=YELLOW).next_to(score_label, RIGHT)\n        lives_label = Text('LIVES:', font_size=32, color=WHITE).to_corner(UR).shift(LEFT*2)\n        hearts = VGroup(*[Text('*', font_size=36, color=RED).shift(RIGHT*i*0.5) for i in range(3)]).next_to(lives_label, RIGHT)\n        level = Text('LEVEL 1', font_size=48, color=GREEN)\n        self.play(Write(score_label), Write(score), Write(lives_label), Create(hearts))\n        self.play(Write(level))\n        self.wait(0.5)\n        self.play(FadeOut(level))\n        self.play(ChangeDecimalToValue(score, 100), run_time=1)\n        self.play(ChangeDecimalToValue(score, 350), run_time=1)\n        self.play(FadeOut(hearts[-1]), run_time=0.3)\n        self.play(ChangeDecimalToValue(score, 500), run_time=1)\n        self.wait()"}
{"prompt": "Show parallel and perpendicular lines with right angle marks", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Parallel and Perpendicular Lines', font_size=32).to_edge(UP)\n        l1 = Line(LEFT*4, RIGHT*4, color=BLUE).shift(UP*1)\n        l2 = Line(LEFT*4, RIGHT*4, color=BLUE).shift(DOWN*1)\n        parallel_marks1 = VGroup(\n            Line(UP*0.15 + LEFT*0.1, DOWN*0.15 + RIGHT*0.1, color=YELLOW, stroke_width=2),\n            Line(UP*0.15 + LEFT*0.1 + RIGHT*0.2, DOWN*0.15 + RIGHT*0.1 + RIGHT*0.2, color=YELLOW, stroke_width=2)\n        ).move_to(l1.get_center())\n        parallel_marks2 = parallel_marks1.copy().move_to(l2.get_center())\n        parallel_label = Text('Parallel', font_size=24, color=BLUE).shift(LEFT*3 + UP*2.3)\n        v1 = Line(DOWN*2.5, UP*2.5, color=RED).shift(RIGHT*0 + DOWN*0)\n        h1 = Line(LEFT*2, RIGHT*2, color=RED).shift(RIGHT*0)\n        right_angle = Square(side_length=0.3, color=WHITE, stroke_width=1.5).align_to(ORIGIN, DL)\n        perp_label = Text('Perpendicular', font_size=24, color=RED).shift(RIGHT*3 + UP*2.3)\n        group1 = VGroup(l1, l2, parallel_marks1, parallel_marks2, parallel_label).shift(LEFT*3 + DOWN*0.5)\n        group2 = VGroup(v1, h1, right_angle, perp_label).shift(RIGHT*2.5 + DOWN*0.5)\n        self.play(Write(title))\n        self.play(Create(group1), run_time=1.5)\n        self.play(Create(group2), run_time=1.5)\n        self.wait()"}
{"prompt": "Animate counting the number of objects in a set", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Counting', font_size=42).to_edge(UP)\n        objects = VGroup()\n        positions = [(x, y) for x in [-2, -0.5, 1, 2.5] for y in [0.5, -1]]\n        colors = [RED, BLUE, GREEN, YELLOW, ORANGE, PURPLE, PINK, TEAL]\n        for i, ((x, y), color) in enumerate(zip(positions[:8], colors)):\n            star = Star(n=5, outer_radius=0.35, inner_radius=0.15, color=color, fill_opacity=0.8)\n            star.move_to([x, y, 0])\n            objects.add(star)\n        self.play(Write(title))\n        self.play(Create(objects))\n        counter = DecimalNumber(0, num_decimal_places=0, font_size=72, color=YELLOW).shift(DOWN*2.5)\n        self.add(counter)\n        for i, obj in enumerate(objects):\n            self.play(\n                Indicate(obj),\n                ChangeDecimalToValue(counter, i+1),\n                run_time=0.4\n            )\n        self.wait()"}
{"prompt": "Show a 3D parametric curve (helix)", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(ThreeDScene):\n    def construct(self):\n        self.set_camera_orientation(phi=70*DEGREES, theta=30*DEGREES)\n        axes = ThreeDAxes(x_range=[-3, 3], y_range=[-3, 3], z_range=[-3, 3])\n        helix = ParametricFunction(\n            lambda t: np.array([np.cos(t), np.sin(t), t/3]),\n            t_range=[-3*PI, 3*PI],\n            color=BLUE\n        )\n        self.play(Create(axes))\n        self.play(Create(helix), run_time=3)\n        self.begin_ambient_camera_rotation(rate=0.4)\n        self.wait(3)"}
{"prompt": "Create an analog clock showing 3:15", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        face = Circle(radius=2.5, color=WHITE)\n        ticks = VGroup()\n        for i in range(12):\n            angle = PI/2 - i*TAU/12\n            inner_r = 2.2 if i % 3 != 0 else 2.0\n            tick = Line(\n                inner_r*np.array([np.cos(angle), np.sin(angle), 0]),\n                2.4*np.array([np.cos(angle), np.sin(angle), 0]),\n                color=WHITE, stroke_width=2 if i % 3 != 0 else 4\n            )\n            ticks.add(tick)\n        numbers = VGroup()\n        for i in range(1, 13):\n            angle = PI/2 - i*TAU/12\n            pos = 1.8*np.array([np.cos(angle), np.sin(angle), 0])\n            numbers.add(Text(str(i), font_size=28).move_to(pos))\n        hour_angle = PI/2 - 3*TAU/12 - 15/60*TAU/12\n        minute_angle = PI/2 - 15*TAU/60\n        hour_hand = Line(ORIGIN, 1.2*np.array([np.cos(hour_angle), np.sin(hour_angle), 0]), color=WHITE, stroke_width=6)\n        minute_hand = Line(ORIGIN, 1.8*np.array([np.cos(minute_angle), np.sin(minute_angle), 0]), color=BLUE, stroke_width=3)\n        center = Dot(ORIGIN, color=WHITE, radius=0.08)\n        time_text = Text('3:15', font_size=36).shift(DOWN*3.2)\n        self.play(Create(face), Create(ticks), Write(numbers))\n        self.play(Create(hour_hand), Create(minute_hand), Create(center))\n        self.play(Write(time_text))\n        self.wait()"}
{"prompt": "Animate the concept of limits approaching a value", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        axes = Axes(x_range=[-1, 5, 1], y_range=[-1, 5, 1])\n        func = axes.plot(lambda x: (x**2 - 4)/(x - 2) if abs(x-2) > 0.01 else 4, x_range=[0, 4], color=BLUE)\n        hole = Circle(radius=0.08, color=WHITE).move_to(axes.c2p(2, 4))\n        title = MathTex('\\\\lim_{x \\\\to 2} \\\\frac{x^2 - 4}{x - 2} = 4', font_size=42).to_edge(UP)\n        left_dot = Dot(axes.c2p(0.5, 2.5), color=RED)\n        right_dot = Dot(axes.c2p(3.5, 5.5), color=GREEN)\n        self.play(Create(axes), Create(func), Create(hole))\n        self.play(Write(title))\n        self.play(Create(left_dot), Create(right_dot))\n        self.play(\n            left_dot.animate.move_to(axes.c2p(1.9, 3.9)),\n            right_dot.animate.move_to(axes.c2p(2.1, 4.1)),\n            run_time=3\n        )\n        self.wait()"}
{"prompt": "Create a visual comparison of area vs perimeter", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Area vs Perimeter', font_size=42).to_edge(UP)\n        sq = Square(side_length=2, color=BLUE, fill_opacity=0.3).shift(LEFT*3)\n        sq_label = Text('4x4', font_size=24).next_to(sq, DOWN)\n        sq_area = MathTex('A = 16', font_size=28, color=BLUE).next_to(sq_label, DOWN)\n        sq_perim = MathTex('P = 16', font_size=28, color=RED).next_to(sq_area, DOWN)\n        rect = Rectangle(width=4, height=1, color=GREEN, fill_opacity=0.3).shift(RIGHT*3)\n        rect_label = Text('8x2', font_size=24).next_to(rect, DOWN)\n        rect_area = MathTex('A = 16', font_size=28, color=GREEN).next_to(rect_label, DOWN)\n        rect_perim = MathTex('P = 20', font_size=28, color=RED).next_to(rect_area, DOWN)\n        note = Text('Same area, different perimeter!', font_size=28, color=YELLOW).shift(DOWN*3)\n        self.play(Write(title))\n        self.play(Create(sq), Write(sq_label), Write(sq_area), Write(sq_perim))\n        self.play(Create(rect), Write(rect_label), Write(rect_area), Write(rect_perim))\n        self.play(Write(note))\n        self.wait()"}
{"prompt": "Animate a simple encryption with Caesar cipher shifting letters", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Caesar Cipher (Shift 3)', font_size=36).to_edge(UP)\n        original = 'HELLO'\n        shifted = 'KHOOR'\n        orig_boxes = VGroup()\n        shift_boxes = VGroup()\n        arrows = VGroup()\n        for i, (o, s) in enumerate(zip(original, shifted)):\n            ob = Square(side_length=0.8, color=BLUE, fill_opacity=0.2).move_to(RIGHT*(i*1.2 - 2.4) + UP*0.8)\n            ot = Text(o, font_size=32, color=BLUE).move_to(ob)\n            sb = Square(side_length=0.8, color=RED, fill_opacity=0.2).move_to(RIGHT*(i*1.2 - 2.4) + DOWN*0.8)\n            st = Text(s, font_size=32, color=RED).move_to(sb)\n            arrow = Arrow(ob.get_bottom(), sb.get_top(), buff=0.1, color=YELLOW)\n            shift_label = Text('+3', font_size=16, color=YELLOW).next_to(arrow, RIGHT, buff=0.05)\n            orig_boxes.add(VGroup(ob, ot))\n            shift_boxes.add(VGroup(sb, st))\n            arrows.add(VGroup(arrow, shift_label))\n        plain_label = Text('Plaintext:', font_size=24).next_to(orig_boxes, LEFT, buff=0.5)\n        cipher_label = Text('Ciphertext:', font_size=24).next_to(shift_boxes, LEFT, buff=0.5)\n        self.play(Write(title))\n        self.play(Create(orig_boxes), Write(plain_label))\n        self.play(Create(arrows))\n        self.play(Create(shift_boxes), Write(cipher_label))\n        self.wait()"}
{"prompt": "Show the double slit experiment concept", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Double Slit Experiment', font_size=36).to_edge(UP)\n        source = Dot(LEFT*5, color=YELLOW, radius=0.15)\n        source_label = Text('Source', font_size=20).next_to(source, DOWN)\n        barrier = Rectangle(width=0.2, height=5, color=GRAY, fill_opacity=0.8).shift(LEFT*1)\n        slit1 = Rectangle(width=0.3, height=0.5, color=BLACK, fill_opacity=1).move_to(LEFT*1 + UP*0.8)\n        slit2 = Rectangle(width=0.3, height=0.5, color=BLACK, fill_opacity=1).move_to(LEFT*1 + DOWN*0.8)\n        screen = Line(RIGHT*4 + DOWN*2.5, RIGHT*4 + UP*2.5, color=WHITE)\n        waves = VGroup()\n        for slit_y in [0.8, -0.8]:\n            for angle in np.linspace(-PI/3, PI/3, 7):\n                wave = Line(\n                    LEFT*1 + UP*slit_y,\n                    LEFT*1 + UP*slit_y + 5*np.array([np.cos(angle), np.sin(angle), 0]),\n                    color=BLUE, stroke_width=1, stroke_opacity=0.5\n                )\n                waves.add(wave)\n        pattern = VGroup()\n        for i in range(9):\n            y = (i - 4) * 0.5\n            intensity = np.cos(i * PI/4)**2\n            bar = Rectangle(width=0.3, height=0.4, fill_color=BLUE, fill_opacity=intensity, stroke_width=0)\n            bar.move_to(RIGHT*4.3 + UP*y)\n            pattern.add(bar)\n        self.play(Write(title))\n        self.play(Create(source), Write(source_label), Create(barrier), FadeIn(slit1), FadeIn(slit2), Create(screen))\n        self.play(Create(waves), run_time=2)\n        self.play(Create(pattern))\n        self.wait()"}
{"prompt": "Create a zoom in effect on a fractal pattern", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        dots = VGroup()\n        for _ in range(500):\n            x, y = 0, 0\n            for _ in range(20):\n                r = np.random.random()\n                if r < 0.01:\n                    x, y = 0, 0.16*y\n                elif r < 0.86:\n                    x, y = 0.85*x+0.04*y, -0.04*x+0.85*y+1.6\n                elif r < 0.93:\n                    x, y = 0.2*x-0.26*y, 0.23*x+0.22*y+1.6\n                else:\n                    x, y = -0.15*x+0.28*y, 0.26*x+0.24*y+0.44\n            dot = Dot([x*0.8, y*0.4 - 2, 0], radius=0.02, color=GREEN)\n            dots.add(dot)\n        self.play(FadeIn(dots), run_time=2)\n        self.play(dots.animate.scale(2).shift(DOWN), run_time=2)\n        self.wait()"}
{"prompt": "Show how binary numbers work from 0 to 15", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Binary Numbers', font_size=42).to_edge(UP)\n        self.play(Write(title))\n        header = VGroup(\n            Text('Decimal', font_size=24, color=YELLOW).shift(LEFT*2),\n            Text('Binary', font_size=24, color=YELLOW).shift(RIGHT*2)\n        ).shift(UP*2)\n        self.play(Write(header))\n        for i in range(8):\n            decimal = Text(str(i), font_size=28).move_to(LEFT*2 + UP*(1 - i*0.5))\n            binary = Text(f'{i:04b}', font_size=28, color=GREEN).move_to(RIGHT*2 + UP*(1 - i*0.5))\n            self.play(Write(decimal), Write(binary), run_time=0.3)\n        self.wait()"}
{"prompt": "Animate a spring compression and extension", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        wall = Line(LEFT*5 + DOWN*1, LEFT*5 + UP*1, color=GRAY, stroke_width=4)\n        def make_spring(length):\n            points = []\n            n_coils = 8\n            for i in range(n_coils * 10 + 1):\n                t = i / (n_coils * 10)\n                x = -5 + t * length\n                y = 0.3 * np.sin(t * n_coils * TAU)\n                points.append([x, y, 0])\n            spring = VMobject(color=BLUE, stroke_width=3)\n            spring.set_points_as_corners(points)\n            return spring\n        block = Square(side_length=0.8, color=RED, fill_opacity=0.7)\n        spring = make_spring(3)\n        block.next_to(spring, RIGHT, buff=0)\n        self.add(wall)\n        self.play(Create(spring), Create(block))\n        compressed = make_spring(1.5)\n        block_c = block.copy().next_to(compressed, RIGHT, buff=0)\n        self.play(Transform(spring, compressed), block.animate.move_to(block_c), run_time=0.5)\n        extended = make_spring(4.5)\n        block_e = block.copy().next_to(extended, RIGHT, buff=0)\n        self.play(Transform(spring, extended), block.animate.move_to(block_e), run_time=0.5)\n        normal = make_spring(3)\n        block_n = block.copy().next_to(normal, RIGHT, buff=0)\n        self.play(Transform(spring, normal), block.animate.move_to(block_n), run_time=0.5)\n        self.wait()"}
{"prompt": "Display a periodic table of the first 10 elements", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('First 10 Elements', font_size=36).to_edge(UP)\n        elements = [\n            (1, 'H', 'Hydrogen'), (2, 'He', 'Helium'),\n            (3, 'Li', 'Lithium'), (4, 'Be', 'Beryllium'),\n            (5, 'B', 'Boron'), (6, 'C', 'Carbon'),\n            (7, 'N', 'Nitrogen'), (8, 'O', 'Oxygen'),\n            (9, 'F', 'Fluorine'), (10, 'Ne', 'Neon'),\n        ]\n        grid = VGroup()\n        for i, (num, sym, name) in enumerate(elements):\n            row, col = i // 5, i % 5\n            box = Rectangle(width=1.8, height=1.3, color=BLUE, fill_opacity=0.1)\n            box.move_to(RIGHT*(col*2 - 4) + DOWN*(row*1.5 - 0.5))\n            n = Text(str(num), font_size=14).move_to(box.get_corner(UL) + DR*0.2)\n            s = Text(sym, font_size=28, weight=BOLD).move_to(box)\n            nm = Text(name, font_size=12).move_to(box.get_bottom() + UP*0.2)\n            grid.add(VGroup(box, n, s, nm))\n        self.play(Write(title))\n        self.play(LaggedStart(*[Create(g) for g in grid], lag_ratio=0.1))\n        self.wait()"}
{"prompt": "Create a simple bar race chart animation", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Bar Race', font_size=36).to_edge(UP)\n        categories = ['A', 'B', 'C', 'D']\n        colors = [RED, BLUE, GREEN, YELLOW]\n        initial = [3, 5, 2, 4]\n        final = [8, 4, 9, 6]\n        bars = VGroup()\n        labels = VGroup()\n        for i, (cat, val, color) in enumerate(zip(categories, initial, colors)):\n            bar = Rectangle(width=val*0.5, height=0.6, fill_color=color, fill_opacity=0.7, color=WHITE)\n            bar.align_to(LEFT*4, LEFT).shift(DOWN*(i*0.9 - 1))\n            label = Text(cat, font_size=24).next_to(bar, LEFT)\n            val_text = Text(str(val), font_size=20).next_to(bar, RIGHT)\n            bars.add(VGroup(bar, val_text))\n            labels.add(label)\n        self.play(Write(title), Write(labels))\n        self.play(Create(bars))\n        new_bars = VGroup()\n        for i, (val, color) in enumerate(zip(final, colors)):\n            bar = Rectangle(width=val*0.5, height=0.6, fill_color=color, fill_opacity=0.7, color=WHITE)\n            bar.align_to(LEFT*4, LEFT).shift(DOWN*(i*0.9 - 1))\n            val_text = Text(str(val), font_size=20).next_to(bar, RIGHT)\n            new_bars.add(VGroup(bar, val_text))\n        self.play(Transform(bars, new_bars), run_time=2)\n        self.wait()"}
{"prompt": "Animate a simple pendulum with energy conservation labels", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        pivot = Dot(UP*2.5, color=WHITE, radius=0.06)\n        length = 2.5\n        angle = ValueTracker(PI/3)\n        rod = always_redraw(lambda: Line(\n            UP*2.5,\n            UP*2.5 + length*np.array([np.sin(angle.get_value()), -np.cos(angle.get_value()), 0]),\n            color=WHITE\n        ))\n        bob = always_redraw(lambda: Dot(\n            UP*2.5 + length*np.array([np.sin(angle.get_value()), -np.cos(angle.get_value()), 0]),\n            color=RED, radius=0.2\n        ))\n        pe_label = always_redraw(lambda: Text(\n            f'PE: {(1-np.cos(angle.get_value()))*100:.0f}%', font_size=24, color=BLUE\n        ).to_corner(UL))\n        ke_label = always_redraw(lambda: Text(\n            f'KE: {np.cos(angle.get_value())*100:.0f}%', font_size=24, color=RED\n        ).next_to(pe_label, DOWN, aligned_edge=LEFT))\n        self.add(pivot, rod, bob, pe_label, ke_label)\n        self.play(angle.animate.set_value(-PI/3), run_time=1, rate_func=there_and_back)\n        self.play(angle.animate.set_value(-PI/3), run_time=1, rate_func=there_and_back)\n        self.play(angle.animate.set_value(-PI/3), run_time=1, rate_func=there_and_back)\n        self.wait()"}
{"prompt": "Show the three primary colors of light (RGB) mixing to white", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Additive Color Mixing (Light)', font_size=32).to_edge(UP)\n        r = Circle(radius=1.5, color=RED, fill_opacity=0.5).shift(LEFT*0.8 + UP*0.5)\n        g = Circle(radius=1.5, color=GREEN, fill_opacity=0.5).shift(RIGHT*0.8 + UP*0.5)\n        b = Circle(radius=1.5, color=BLUE, fill_opacity=0.5).shift(DOWN*0.5)\n        r_label = Text('R', font_size=28, color=RED).move_to(LEFT*2.2 + UP*1.5)\n        g_label = Text('G', font_size=28, color=GREEN).move_to(RIGHT*2.2 + UP*1.5)\n        b_label = Text('B', font_size=28, color=BLUE).move_to(DOWN*2)\n        white_dot = Dot(ORIGIN, color=WHITE, radius=0.3)\n        white_label = Text('White', font_size=20, color=WHITE).next_to(white_dot, DOWN, buff=0.4)\n        self.play(Write(title))\n        self.play(Create(r), Create(g), Create(b))\n        self.play(Write(r_label), Write(g_label), Write(b_label))\n        self.play(Create(white_dot), Write(white_label))\n        self.wait()"}
{"prompt": "Create a visual explanation of the Monty Hall problem", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Monty Hall Problem', font_size=42).to_edge(UP)\n        doors = VGroup()\n        for i in range(3):\n            door = Rectangle(width=2, height=3, color=BLUE, fill_opacity=0.3)\n            door.shift(RIGHT*(i*2.5 - 2.5))\n            num = Text(str(i+1), font_size=36).move_to(door.get_top() + DOWN*0.5)\n            doors.add(VGroup(door, num))\n        self.play(Write(title))\n        self.play(Create(doors))\n        car = Text('CAR', font_size=24, color=GREEN).move_to(doors[1].get_center())\n        goat1 = Text('GOAT', font_size=24, color=RED).move_to(doors[0].get_center())\n        goat2 = Text('GOAT', font_size=24, color=RED).move_to(doors[2].get_center())\n        pick = Text('Your pick', font_size=20, color=YELLOW).next_to(doors[0], DOWN)\n        self.play(Write(pick))\n        self.play(doors[2][0].animate.set_fill(RED, opacity=0.3), Write(goat2))\n        switch = Text('Switch to win!', font_size=28, color=GREEN).shift(DOWN*3)\n        self.play(Write(switch))\n        self.play(doors[1][0].animate.set_fill(GREEN, opacity=0.3), Write(car))\n        prob = MathTex('P(\\\\text{win with switch}) = \\\\frac{2}{3}', font_size=32).shift(DOWN*2)\n        self.play(Write(prob))\n        self.wait()"}
{"prompt": "Animate drawing an Archimedes spiral", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        spiral = ParametricFunction(\n            lambda t: np.array([(0.1*t)*np.cos(t), (0.1*t)*np.sin(t), 0]),\n            t_range=[0, 8*PI],\n            color=BLUE\n        )\n        title = Text('Archimedes Spiral', font_size=36).to_edge(UP)\n        formula = MathTex('r = a + b\\\\theta', font_size=32).to_corner(DR)\n        self.play(Write(title))\n        self.play(Create(spiral), run_time=4)\n        self.play(Write(formula))\n        self.wait()"}
{"prompt": "Show the difference between velocity and speed", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Speed vs Velocity', font_size=42).to_edge(UP)\n        speed_section = VGroup(\n            Text('Speed', font_size=32, color=BLUE),\n            Text('Scalar quantity', font_size=22),\n            Text('Only magnitude', font_size=22),\n            MathTex('|v| = \\\\frac{distance}{time}', font_size=32, color=BLUE),\n            Text('Example: 60 km/h', font_size=22, color=GRAY)\n        ).arrange(DOWN, buff=0.3).shift(LEFT*3 + DOWN*0.5)\n        vel_section = VGroup(\n            Text('Velocity', font_size=32, color=RED),\n            Text('Vector quantity', font_size=22),\n            Text('Magnitude + Direction', font_size=22),\n            MathTex('\\\\vec{v} = \\\\frac{displacement}{time}', font_size=32, color=RED),\n            Text('Example: 60 km/h North', font_size=22, color=GRAY)\n        ).arrange(DOWN, buff=0.3).shift(RIGHT*3 + DOWN*0.5)\n        divider = Line(UP*2, DOWN*3, color=GRAY)\n        self.play(Write(title))\n        self.play(Create(divider))\n        self.play(Write(speed_section), run_time=2)\n        self.play(Write(vel_section), run_time=2)\n        self.wait()"}
{"prompt": "Create a Koch snowflake animation", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        def koch_points(p1, p2, depth):\n            if depth == 0:\n                return [p1]\n            d = (p2 - p1) / 3\n            a = p1 + d\n            c = p1 + 2*d\n            angle = np.arctan2(d[1], d[0]) + PI/3\n            b = a + np.linalg.norm(d) * np.array([np.cos(angle), np.sin(angle), 0])\n            pts = koch_points(p1, a, depth-1)\n            pts += koch_points(a, b, depth-1)\n            pts += koch_points(b, c, depth-1)\n            pts += koch_points(c, p2, depth-1)\n            return pts\n        def snowflake(depth):\n            s = 4\n            p1 = np.array([-s/2, -s*np.sqrt(3)/6, 0])\n            p2 = np.array([s/2, -s*np.sqrt(3)/6, 0])\n            p3 = np.array([0, s*np.sqrt(3)/3, 0])\n            pts = koch_points(p1, p2, depth)\n            pts += koch_points(p2, p3, depth)\n            pts += koch_points(p3, p1, depth)\n            pts.append(pts[0])\n            shape = VMobject(color=BLUE)\n            shape.set_points_as_corners(pts)\n            return shape\n        title = Text('Koch Snowflake', font_size=36).to_edge(UP)\n        self.play(Write(title))\n        shape = snowflake(0)\n        self.play(Create(shape))\n        for d in range(1, 5):\n            new_shape = snowflake(d)\n            self.play(Transform(shape, new_shape), run_time=1)\n        self.wait()"}
{"prompt": "Animate a metronome ticking", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        base = Polygon(\n            [-1, -3, 0], [1, -3, 0], [0.3, 0, 0], [-0.3, 0, 0],\n            color=DARK_BROWN, fill_opacity=0.5\n        )\n        pivot = Dot(UP*0, color=WHITE, radius=0.06)\n        angle = ValueTracker(PI/6)\n        arm = always_redraw(lambda: Line(\n            ORIGIN,\n            2.5*np.array([np.sin(angle.get_value()), np.cos(angle.get_value()), 0]),\n            color=WHITE, stroke_width=3\n        ))\n        weight = always_redraw(lambda: Dot(\n            1.5*np.array([np.sin(angle.get_value()), np.cos(angle.get_value()), 0]),\n            color=RED, radius=0.15\n        ))\n        bpm = Text('120 BPM', font_size=28).to_edge(UP)\n        self.add(base, pivot, arm, weight)\n        self.play(Write(bpm))\n        for _ in range(4):\n            self.play(angle.animate.set_value(-PI/6), run_time=0.5, rate_func=smooth)\n            self.play(angle.animate.set_value(PI/6), run_time=0.5, rate_func=smooth)\n        self.wait()"}
{"prompt": "Show different types of angles: acute, right, obtuse", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Types of Angles', font_size=42).to_edge(UP)\n        angles_data = [\n            ('Acute', PI/4, GREEN, LEFT*4),\n            ('Right', PI/2, BLUE, ORIGIN),\n            ('Obtuse', 3*PI/4, RED, RIGHT*4),\n        ]\n        groups = VGroup()\n        for name, angle_val, color, pos in angles_data:\n            line1 = Line(ORIGIN, RIGHT*1.5, color=color)\n            line2 = Line(ORIGIN, 1.5*np.array([np.cos(angle_val), np.sin(angle_val), 0]), color=color)\n            arc = Angle(line1, line2, radius=0.5, color=YELLOW)\n            label = Text(name, font_size=24, color=color).shift(DOWN*0.8)\n            deg = MathTex(f'{int(np.degrees(angle_val))}^\\\\circ', font_size=24).shift(UP*0.8)\n            group = VGroup(line1, line2, arc, label, deg).shift(pos + DOWN*0.5)\n            groups.add(group)\n        self.play(Write(title))\n        for g in groups:\n            self.play(Create(g), run_time=0.8)\n        self.wait()"}
{"prompt": "Create an animated clock with second hand moving smoothly", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        face = Circle(radius=2.5, color=WHITE)\n        ticks = VGroup()\n        for i in range(60):\n            angle = PI/2 - i*TAU/60\n            inner = 2.3 if i % 5 != 0 else 2.1\n            width = 1 if i % 5 != 0 else 2\n            tick = Line(\n                inner*np.array([np.cos(angle), np.sin(angle), 0]),\n                2.4*np.array([np.cos(angle), np.sin(angle), 0]),\n                color=WHITE, stroke_width=width\n            )\n            ticks.add(tick)\n        center = Dot(ORIGIN, color=WHITE, radius=0.06)\n        second_hand = Line(ORIGIN, UP*2, color=RED, stroke_width=2)\n        self.play(Create(face), Create(ticks), Create(center))\n        self.add(second_hand)\n        self.play(Rotate(second_hand, -TAU, about_point=ORIGIN, rate_func=linear), run_time=5)\n        self.wait()"}
{"prompt": "Show the relationship between a circle and its inscribed square", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        circle = Circle(radius=2, color=BLUE)\n        square = Square(side_length=2*np.sqrt(2), color=RED).rotate(PI/4)\n        radius = Line(ORIGIN, RIGHT*2, color=YELLOW)\n        r_label = MathTex('r', font_size=32, color=YELLOW).next_to(radius, DOWN, buff=0.1)\n        diagonal = Line(square.get_corner(DL), square.get_corner(UR), color=GREEN, stroke_width=2)\n        d_label = MathTex('d = 2r', font_size=28, color=GREEN).next_to(diagonal, RIGHT)\n        side_label = MathTex('s = r\\\\sqrt{2}', font_size=28, color=RED).shift(DOWN*2.5)\n        self.play(Create(circle))\n        self.play(Create(square))\n        self.play(Create(radius), Write(r_label))\n        self.play(Create(diagonal), Write(d_label))\n        self.play(Write(side_label))\n        self.wait()"}
{"prompt": "Animate a wave packet moving through space", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        axes = Axes(x_range=[-8, 8, 2], y_range=[-2, 2, 1])\n        t = ValueTracker(-4)\n        wave = always_redraw(lambda: axes.plot(\n            lambda x: np.exp(-0.5*(x - t.get_value())**2) * np.sin(5*x),\n            x_range=[-8, 8],\n            color=BLUE\n        ))\n        envelope = always_redraw(lambda: axes.plot(\n            lambda x: np.exp(-0.5*(x - t.get_value())**2),\n            x_range=[-8, 8],\n            color=RED, stroke_width=1.5\n        ))\n        title = Text('Wave Packet', font_size=36).to_edge(UP)\n        self.play(Create(axes), Write(title))\n        self.add(wave, envelope)\n        self.play(t.animate.set_value(4), run_time=4, rate_func=linear)\n        self.wait()"}
{"prompt": "Create a visual explanation of Big O notation with examples", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Big O Notation', font_size=42).to_edge(UP)\n        examples = [\n            ('O(1)', 'Array access', GREEN),\n            ('O(log n)', 'Binary search', BLUE),\n            ('O(n)', 'Linear search', YELLOW),\n            ('O(n log n)', 'Merge sort', ORANGE),\n            ('O(n^2)', 'Bubble sort', RED),\n        ]\n        rows = VGroup()\n        for i, (notation, algo, color) in enumerate(examples):\n            n = MathTex(notation, font_size=32, color=color).shift(LEFT*2 + DOWN*(i*0.7 - 1))\n            dash = Text(' -- ', font_size=24).next_to(n, RIGHT)\n            a = Text(algo, font_size=24).next_to(dash, RIGHT)\n            bar = Rectangle(width=(i+1)*0.8, height=0.3, fill_color=color, fill_opacity=0.5).next_to(a, RIGHT, buff=0.3)\n            rows.add(VGroup(n, dash, a, bar))\n        self.play(Write(title))\n        for row in rows:\n            self.play(FadeIn(row), run_time=0.5)\n        self.wait()"}
{"prompt": "Show a simple A* pathfinding visualization on a grid", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('A* Pathfinding', font_size=36).to_edge(UP)\n        size = 0.6\n        grid = VGroup()\n        for r in range(7):\n            for c in range(7):\n                sq = Square(side_length=size, color=GRAY, stroke_width=0.5)\n                sq.move_to(RIGHT*(c*size - 1.8) + UP*(r*size - 1.8))\n                grid.add(sq)\n        walls = [(2,1),(2,2),(2,3),(2,4),(4,2),(4,3),(4,4),(4,5)]\n        for r,c in walls:\n            grid[r*7+c].set_fill(DARK_GRAY, opacity=0.8)\n        start = grid[0*7+0]\n        end = grid[6*7+6]\n        start.set_fill(GREEN, opacity=0.8)\n        end.set_fill(RED, opacity=0.8)\n        path = [(0,0),(1,0),(1,1),(1,2),(1,3),(1,4),(1,5),(2,5),(3,5),(3,6),(4,6),(5,6),(6,6)]\n        self.play(Write(title), Create(grid))\n        for r,c in path[1:-1]:\n            self.play(grid[r*7+c].animate.set_fill(BLUE, opacity=0.5), run_time=0.2)\n        self.wait()"}
{"prompt": "Animate the planets of our solar system in order", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Solar System', font_size=36).to_edge(UP)\n        planets = [\n            ('Mercury', GRAY, 0.08),\n            ('Venus', ORANGE, 0.12),\n            ('Earth', BLUE, 0.13),\n            ('Mars', RED, 0.1),\n            ('Jupiter', GOLD, 0.25),\n            ('Saturn', YELLOW, 0.22),\n            ('Uranus', TEAL, 0.18),\n            ('Neptune', BLUE_D, 0.17),\n        ]\n        self.play(Write(title))\n        sun = Dot(LEFT*5.5, color=YELLOW, radius=0.4)\n        self.play(Create(sun))\n        planet_group = VGroup()\n        for i, (name, color, radius) in enumerate(planets):\n            x = -4 + i * 1.3\n            dot = Dot([x, 0, 0], color=color, radius=radius)\n            label = Text(name, font_size=14).next_to(dot, DOWN, buff=0.2)\n            planet_group.add(VGroup(dot, label))\n        self.play(LaggedStart(*[FadeIn(p) for p in planet_group], lag_ratio=0.2))\n        self.wait()"}
{"prompt": "Create a visual proof of the sum of first n odd numbers equals n squared", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('1 + 3 + 5 + ... + (2n-1) = n^2', font_size=32).to_edge(UP)\n        colors = [RED, BLUE, GREEN, YELLOW]\n        squares = VGroup()\n        for n in range(1, 5):\n            layer = VGroup()\n            for i in range(n):\n                sq = Square(side_length=0.6, color=colors[n-1], fill_opacity=0.5)\n                sq.move_to(RIGHT*(i*0.6) + UP*((n-1)*0.6))\n                layer.add(sq)\n            for j in range(n-1):\n                sq = Square(side_length=0.6, color=colors[n-1], fill_opacity=0.5)\n                sq.move_to(RIGHT*((n-1)*0.6) + UP*(j*0.6))\n                layer.add(sq)\n            squares.add(layer)\n        group = VGroup(*squares).move_to(ORIGIN).shift(DOWN*0.5)\n        self.play(Write(title))\n        labels = ['1', '+3', '+5', '+7']\n        for i, (layer, label) in enumerate(zip(squares, labels)):\n            l = Text(label, font_size=24, color=colors[i]).shift(RIGHT*4 + DOWN*(i*0.6 - 0.5))\n            self.play(Create(layer), Write(l), run_time=0.5)\n        result = MathTex('= 4^2 = 16', font_size=36).shift(DOWN*2.5)\n        self.play(Write(result))\n        self.wait()"}
{"prompt": "Show electromagnetic wave with E and B fields", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Electromagnetic Wave', font_size=36).to_edge(UP)\n        x_axis = Arrow(LEFT*5, RIGHT*5, color=WHITE, stroke_width=2)\n        x_label = Text('Direction', font_size=20).next_to(x_axis, RIGHT)\n        e_wave = ParametricFunction(\n            lambda t: np.array([t, np.sin(t), 0]),\n            t_range=[-4, 4],\n            color=RED\n        )\n        b_wave = ParametricFunction(\n            lambda t: np.array([t, 0, np.sin(t)]),\n            t_range=[-4, 4],\n            color=BLUE\n        )\n        e_label = Text('E field', font_size=22, color=RED).shift(UP*1.5 + LEFT*3)\n        b_label = Text('B field', font_size=22, color=BLUE).shift(DOWN*1.5 + LEFT*3)\n        self.play(Write(title))\n        self.play(Create(x_axis), Write(x_label))\n        self.play(Create(e_wave), Write(e_label))\n        self.play(Create(b_wave), Write(b_label))\n        self.wait()"}
{"prompt": "Create a visual encoding of Morse code for SOS", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Morse Code: SOS', font_size=42).to_edge(UP)\n        letters = [\n            ('S', '...', [0.3, 0.3, 0.3]),\n            ('O', '---', [0.9, 0.9, 0.9]),\n            ('S', '...', [0.3, 0.3, 0.3]),\n        ]\n        group = VGroup()\n        x = -4\n        for letter, morse, widths in letters:\n            l = Text(letter, font_size=36, color=YELLOW).move_to([x-0.3, 1, 0])\n            m = Text(morse, font_size=28, color=GRAY).move_to([x-0.3, 0.3, 0])\n            group.add(l, m)\n            for w in widths:\n                bar = Rectangle(width=w, height=0.4, fill_color=GREEN, fill_opacity=0.8, color=GREEN)\n                bar.move_to([x, -0.5, 0])\n                group.add(bar)\n                x += w + 0.2\n            x += 0.5\n        group.move_to(ORIGIN)\n        self.play(Write(title))\n        self.play(LaggedStart(*[Create(g) for g in group], lag_ratio=0.1), run_time=3)\n        self.wait()"}
{"prompt": "Animate a domino chain falling", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        dominoes = VGroup()\n        for i in range(8):\n            domino = Rectangle(width=0.3, height=1.5, color=WHITE, fill_opacity=0.3)\n            domino.move_to(RIGHT*(i*0.8 - 2.8) + DOWN*0.25)\n            domino.rotate(0)\n            dominoes.add(domino)\n        ground = Line(LEFT*5, RIGHT*5, color=GRAY).shift(DOWN*1)\n        self.add(ground)\n        self.play(Create(dominoes))\n        for i, domino in enumerate(dominoes):\n            self.play(\n                Rotate(domino, -PI/3, about_point=domino.get_corner(DR)),\n                run_time=0.2\n            )\n        self.wait()"}
{"prompt": "Show the concept of supply and demand curves crossing", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Supply and Demand', font_size=36).to_edge(UP)\n        axes = Axes(x_range=[0, 10, 2], y_range=[0, 10, 2], x_length=6, y_length=5, axis_config={'include_numbers': True})\n        x_label = Text('Quantity', font_size=22).next_to(axes.x_axis, DOWN)\n        y_label = Text('Price', font_size=22).next_to(axes.y_axis, LEFT).rotate(PI/2)\n        demand = axes.plot(lambda x: 8 - 0.7*x, x_range=[0, 10], color=RED)\n        supply = axes.plot(lambda x: 1 + 0.7*x, x_range=[0, 10], color=BLUE)\n        d_label = Text('Demand', font_size=20, color=RED).move_to(axes.c2p(9, 2))\n        s_label = Text('Supply', font_size=20, color=BLUE).move_to(axes.c2p(9, 8))\n        eq_x = 5\n        eq_y = 4.5\n        eq_dot = Dot(axes.c2p(eq_x, eq_y), color=GREEN, radius=0.1)\n        eq_label = Text('Equilibrium', font_size=20, color=GREEN).next_to(eq_dot, UR)\n        self.play(Write(title))\n        self.play(Create(axes), Write(x_label), Write(y_label))\n        self.play(Create(demand), Write(d_label))\n        self.play(Create(supply), Write(s_label))\n        self.play(Create(eq_dot), Write(eq_label))\n        self.wait()"}
{"prompt": "Create a colorful mandala pattern", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        mandala = VGroup()\n        colors = [RED, ORANGE, YELLOW, GREEN, BLUE, PURPLE, PINK, TEAL]\n        for layer in range(4):\n            r = 0.5 + layer * 0.6\n            n_petals = 6 + layer * 2\n            for i in range(n_petals):\n                angle = i * TAU / n_petals\n                petal = Ellipse(width=0.8, height=0.3, color=colors[(layer+i) % len(colors)], fill_opacity=0.5)\n                petal.rotate(angle).shift(r * np.array([np.cos(angle), np.sin(angle), 0]))\n                mandala.add(petal)\n        center = Circle(radius=0.3, color=YELLOW, fill_opacity=0.8)\n        mandala.add(center)\n        self.play(Create(mandala), run_time=3)\n        self.play(Rotate(mandala, TAU/6), run_time=2)\n        self.wait()"}
{"prompt": "Animate the concept of a function mapping inputs to outputs", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Function: f(x) = 2x + 1', font_size=36).to_edge(UP)\n        input_box = Rectangle(width=2, height=3, color=BLUE, fill_opacity=0.1).shift(LEFT*4)\n        output_box = Rectangle(width=2, height=3, color=RED, fill_opacity=0.1).shift(RIGHT*4)\n        func_box = Rectangle(width=2.5, height=1.5, color=GREEN, fill_opacity=0.2)\n        func_label = MathTex('f(x)=2x+1', font_size=28, color=GREEN).move_to(func_box)\n        in_label = Text('Input', font_size=22).next_to(input_box, UP)\n        out_label = Text('Output', font_size=22).next_to(output_box, UP)\n        a1 = Arrow(input_box.get_right(), func_box.get_left(), buff=0.1)\n        a2 = Arrow(func_box.get_right(), output_box.get_left(), buff=0.1)\n        self.play(Write(title))\n        self.play(Create(input_box), Write(in_label), Create(func_box), Write(func_label), Create(output_box), Write(out_label))\n        self.play(GrowArrow(a1), GrowArrow(a2))\n        for x in [1, 2, 3]:\n            inp = Text(str(x), font_size=28, color=BLUE).move_to(input_box)\n            out = Text(str(2*x+1), font_size=28, color=RED).move_to(output_box)\n            self.play(Write(inp), run_time=0.3)\n            self.play(Write(out), run_time=0.3)\n            self.wait(0.3)\n            self.play(FadeOut(inp), FadeOut(out), run_time=0.2)\n        self.wait()"}
{"prompt": "Show a simple LR circuit diagram", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('LR Circuit', font_size=36).to_edge(UP)\n        wire1 = Line(LEFT*3 + DOWN, LEFT*3 + UP*2, color=WHITE)\n        wire2 = Line(LEFT*3 + UP*2, RIGHT*3 + UP*2, color=WHITE)\n        wire3 = Line(RIGHT*3 + UP*2, RIGHT*3 + DOWN, color=WHITE)\n        wire4 = Line(RIGHT*3 + DOWN, LEFT*3 + DOWN, color=WHITE)\n        battery = VGroup(\n            Line(LEFT*3 + DOWN + UP*0.6, LEFT*3 + DOWN + UP*0.8, color=RED, stroke_width=3),\n            Line(LEFT*3.15 + DOWN + UP*0.4, LEFT*3.15 + DOWN + UP*1, color=RED, stroke_width=1),\n        )\n        resistor = VGroup()\n        for i in range(4):\n            x = -1 + i*0.5\n            resistor.add(Line([x, 2, 0], [x+0.25, 2.3, 0], color=YELLOW))\n            resistor.add(Line([x+0.25, 2.3, 0], [x+0.5, 1.7, 0], color=YELLOW))\n        r_label = MathTex('R', font_size=32, color=YELLOW).shift(UP*2.8)\n        inductor = Ellipse(width=2, height=0.5, color=BLUE).shift(RIGHT*3 + UP*0.5)\n        l_label = MathTex('L', font_size=32, color=BLUE).next_to(inductor, RIGHT)\n        v_label = MathTex('V', font_size=32, color=RED).next_to(battery, LEFT)\n        formula = MathTex('V = IR + L\\\\frac{dI}{dt}', font_size=36).shift(DOWN*2.5)\n        self.play(Write(title))\n        self.play(Create(wire1), Create(wire2), Create(wire3), Create(wire4))\n        self.play(Create(battery), Write(v_label))\n        self.play(Create(resistor), Write(r_label))\n        self.play(Create(inductor), Write(l_label))\n        self.play(Write(formula))\n        self.wait()"}
{"prompt": "Create a staircase function visualization", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        axes = Axes(x_range=[-1, 6, 1], y_range=[-1, 6, 1], axis_config={'include_numbers': True})\n        title = Text('Floor Function', font_size=36).to_edge(UP)\n        steps = VGroup()\n        for i in range(6):\n            step = Line(axes.c2p(i, i), axes.c2p(i+1, i), color=BLUE, stroke_width=3)\n            left_dot = Dot(axes.c2p(i, i), color=BLUE, radius=0.06)\n            right_dot = Circle(radius=0.06, color=BLUE).move_to(axes.c2p(i+1, i))\n            steps.add(step, left_dot, right_dot)\n        formula = MathTex('f(x) = \\\\lfloor x \\\\rfloor', font_size=36).to_corner(UR)\n        self.play(Write(title), Create(axes))\n        self.play(Create(steps), Write(formula), run_time=2)\n        self.wait()"}
{"prompt": "Animate drawing a house step by step", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        base = Rectangle(width=4, height=3, color=WHITE).shift(DOWN*0.5)\n        roof = Polygon([-2.5, 1, 0], [0, 3, 0], [2.5, 1, 0], color=RED, fill_opacity=0.3)\n        door = Rectangle(width=1, height=1.5, color=ORANGE, fill_opacity=0.5).align_to(base, DOWN).shift(LEFT*0.8)\n        window1 = Square(side_length=0.8, color=BLUE, fill_opacity=0.3).move_to(RIGHT*1 + UP*0.2)\n        window2 = Square(side_length=0.8, color=BLUE, fill_opacity=0.3).move_to(LEFT*1 + UP*0.2)\n        chimney = Rectangle(width=0.6, height=1, color=DARK_GRAY, fill_opacity=0.5).move_to(RIGHT*1.2 + UP*2.5)\n        knob = Dot(door.get_right() + LEFT*0.2, color=YELLOW, radius=0.06)\n        self.play(Create(base))\n        self.play(Create(roof))\n        self.play(Create(door), Create(knob))\n        self.play(Create(window1), Create(window2))\n        self.play(Create(chimney))\n        self.wait()"}
{"prompt": "Show the concept of gradient descent on a parabola", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Gradient Descent', font_size=36).to_edge(UP)\n        axes = Axes(x_range=[-4, 4, 1], y_range=[-1, 16, 4])\n        curve = axes.plot(lambda x: x**2, color=BLUE)\n        label = MathTex('f(x) = x^2', font_size=32).to_corner(UR)\n        self.play(Write(title), Create(axes), Create(curve), Write(label))\n        x = 3.5\n        lr = 0.3\n        dot = Dot(axes.c2p(x, x**2), color=RED)\n        self.play(Create(dot))\n        for _ in range(8):\n            grad = 2 * x\n            x_new = x - lr * grad\n            new_dot = Dot(axes.c2p(x_new, x_new**2), color=RED)\n            self.play(Transform(dot, new_dot), run_time=0.4)\n            x = x_new\n        self.wait()"}
{"prompt": "Create a visual explanation of how encryption works", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Encryption', font_size=42).to_edge(UP)\n        msg = Text('HELLO', font_size=36, color=GREEN).shift(LEFT*4 + UP*0.5)\n        key = Text('KEY', font_size=28, color=YELLOW).shift(UP*2)\n        lock = Circle(radius=0.5, color=YELLOW, fill_opacity=0.3).shift(UP*2 + RIGHT*1)\n        encrypted = Text('X#K!9', font_size=36, color=RED).shift(RIGHT*4 + UP*0.5)\n        arrow1 = Arrow(msg.get_right(), ORIGIN + LEFT*0.5, buff=0.2)\n        encrypt_box = Rectangle(width=2, height=1.2, color=PURPLE, fill_opacity=0.2)\n        encrypt_label = Text('Encrypt', font_size=22).move_to(encrypt_box)\n        arrow2 = Arrow(ORIGIN + RIGHT*0.5, encrypted.get_left(), buff=0.2)\n        self.play(Write(title))\n        self.play(Write(msg))\n        self.play(Create(encrypt_box), Write(encrypt_label))\n        self.play(Write(key), Create(lock))\n        self.play(GrowArrow(arrow1))\n        self.play(GrowArrow(arrow2), Write(encrypted))\n        self.wait()"}
{"prompt": "Animate a Lissajous curve being drawn", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        curve = ParametricFunction(\n            lambda t: np.array([3*np.sin(3*t + PI/2), 2*np.sin(2*t), 0]),\n            t_range=[0, TAU],\n            color=BLUE\n        )\n        title = Text('Lissajous Curve (3:2)', font_size=36).to_edge(UP)\n        self.play(Write(title))\n        self.play(Create(curve), run_time=4)\n        self.wait()"}
{"prompt": "Show the concept of inheritance in object-oriented programming", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('OOP Inheritance', font_size=36).to_edge(UP)\n        parent = Rectangle(width=3, height=1.2, color=BLUE, fill_opacity=0.2).shift(UP*1.5)\n        parent_label = Text('Animal', font_size=28, color=BLUE).move_to(parent)\n        child1 = Rectangle(width=2.5, height=1.2, color=GREEN, fill_opacity=0.2).shift(DOWN*0.5 + LEFT*2.5)\n        child1_label = Text('Dog', font_size=28, color=GREEN).move_to(child1)\n        child2 = Rectangle(width=2.5, height=1.2, color=RED, fill_opacity=0.2).shift(DOWN*0.5 + RIGHT*2.5)\n        child2_label = Text('Cat', font_size=28, color=RED).move_to(child2)\n        arrow1 = Arrow(parent.get_bottom() + LEFT*0.5, child1.get_top(), buff=0.1, color=GRAY)\n        arrow2 = Arrow(parent.get_bottom() + RIGHT*0.5, child2.get_top(), buff=0.1, color=GRAY)\n        inherits = Text('inherits', font_size=18, color=GRAY)\n        methods = VGroup(\n            Text('speak()', font_size=20).shift(DOWN*2 + LEFT*2.5),\n            Text('bark()', font_size=20, color=GREEN).shift(DOWN*2.5 + LEFT*2.5),\n            Text('speak()', font_size=20).shift(DOWN*2 + RIGHT*2.5),\n            Text('meow()', font_size=20, color=RED).shift(DOWN*2.5 + RIGHT*2.5),\n        )\n        self.play(Write(title))\n        self.play(Create(parent), Write(parent_label))\n        self.play(GrowArrow(arrow1), GrowArrow(arrow2))\n        self.play(Create(child1), Write(child1_label), Create(child2), Write(child2_label))\n        self.play(Write(methods))\n        self.wait()"}
{"prompt": "Create a visual of the golden ratio in a rectangle", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        phi = (1 + np.sqrt(5)) / 2\n        title = Text('Golden Ratio', font_size=42).to_edge(UP)\n        rect = Rectangle(width=phi*2, height=2, color=GOLD).shift(LEFT*0.5)\n        square = Square(side_length=2, color=BLUE, fill_opacity=0.1).align_to(rect, LEFT).align_to(rect, DOWN)\n        divider = Line(square.get_corner(UR), square.get_corner(DR), color=RED, stroke_width=2)\n        phi_label = MathTex('\\\\phi = \\\\frac{1 + \\\\sqrt{5}}{2} \\\\approx 1.618', font_size=36).shift(DOWN*2)\n        a_label = MathTex('1', font_size=28, color=BLUE).next_to(square, DOWN, buff=0.1)\n        b_label = MathTex('\\\\phi - 1', font_size=24, color=GOLD).shift(RIGHT*1.5 + DOWN*1.2)\n        self.play(Write(title))\n        self.play(Create(rect))\n        self.play(Create(square), Create(divider))\n        self.play(Write(a_label), Write(b_label))\n        self.play(Write(phi_label))\n        self.wait()"}
{"prompt": "Animate water waves using parametric curves", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        t = ValueTracker(0)\n        waves = VGroup()\n        for y_offset in np.linspace(-2, 2, 6):\n            wave = always_redraw(lambda y=y_offset: ParametricFunction(\n                lambda x: np.array([x, y + 0.3*np.sin(2*x - t.get_value()), 0]),\n                t_range=[-6, 6],\n                color=BLUE,\n                stroke_opacity=0.5\n            ))\n            waves.add(wave)\n        title = Text('Ocean Waves', font_size=36).to_edge(UP)\n        self.play(Write(title))\n        self.add(*waves)\n        self.play(t.animate.set_value(4*PI), run_time=5, rate_func=linear)\n        self.wait()"}
{"prompt": "Show how HTTPS works with a client-server diagram", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('HTTPS Connection', font_size=36).to_edge(UP)\n        client = Rectangle(width=2, height=1.5, color=BLUE, fill_opacity=0.2).shift(LEFT*4)\n        client_label = Text('Client', font_size=22).move_to(client)\n        server = Rectangle(width=2, height=1.5, color=GREEN, fill_opacity=0.2).shift(RIGHT*4)\n        server_label = Text('Server', font_size=22).move_to(server)\n        lock = Text('HTTPS', font_size=20, color=YELLOW).shift(UP*2)\n        steps = [\n            ('1. Hello', BLUE, 0.5),\n            ('2. Certificate', GREEN, -0.5),\n            ('3. Key Exchange', BLUE, -1.5),\n            ('4. Encrypted Data', YELLOW, -2.5),\n        ]\n        self.play(Write(title))\n        self.play(Create(client), Write(client_label), Create(server), Write(server_label), Write(lock))\n        for text, color, y in steps:\n            if color == BLUE:\n                arrow = Arrow(client.get_right(), server.get_left(), buff=0.2, color=color).shift(UP*y)\n            else:\n                arrow = Arrow(server.get_left(), client.get_right(), buff=0.2, color=color).shift(UP*y)\n            label = Text(text, font_size=18, color=color).next_to(arrow, UP, buff=0.05)\n            self.play(GrowArrow(arrow), Write(label), run_time=0.5)\n        self.wait()"}
{"prompt": "Create a visual for the Pythagorean triples 3-4-5 and 5-12-13", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Pythagorean Triples', font_size=42).to_edge(UP)\n        t1 = Polygon([0,0,0], [3,0,0], [0,4,0], color=BLUE, fill_opacity=0.2).scale(0.5).shift(LEFT*3)\n        t1_labels = VGroup(\n            MathTex('3', font_size=28).next_to(t1, DOWN),\n            MathTex('4', font_size=28).next_to(t1, LEFT),\n            MathTex('5', font_size=28, color=RED).move_to(t1.get_center() + UR*0.5)\n        )\n        eq1 = MathTex('3^2 + 4^2 = 5^2', font_size=28, color=BLUE).shift(LEFT*3 + DOWN*2)\n        t2 = Polygon([0,0,0], [5,0,0], [0,12,0], color=GREEN, fill_opacity=0.2).scale(0.2).shift(RIGHT*3)\n        t2_labels = VGroup(\n            MathTex('5', font_size=28).next_to(t2, DOWN),\n            MathTex('12', font_size=28).next_to(t2, LEFT),\n            MathTex('13', font_size=28, color=RED).move_to(t2.get_center() + UR*0.5)\n        )\n        eq2 = MathTex('5^2 + 12^2 = 13^2', font_size=28, color=GREEN).shift(RIGHT*3 + DOWN*2)\n        self.play(Write(title))\n        self.play(Create(t1), Write(t1_labels))\n        self.play(Write(eq1))\n        self.play(Create(t2), Write(t2_labels))\n        self.play(Write(eq2))\n        self.wait()"}
{"prompt": "Animate a simple particle collision", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        p1 = Dot(LEFT*4, color=RED, radius=0.25)\n        p2 = Dot(RIGHT*4, color=BLUE, radius=0.25)\n        l1 = Text('m=2', font_size=20, color=RED).next_to(p1, UP)\n        l2 = Text('m=1', font_size=20, color=BLUE).next_to(p2, UP)\n        v1 = Arrow(LEFT*4, LEFT*2.5, color=RED, buff=0, stroke_width=3)\n        v2 = Arrow(RIGHT*4, RIGHT*2.5, color=BLUE, buff=0, stroke_width=3)\n        title = Text('Elastic Collision', font_size=36).to_edge(UP)\n        self.play(Write(title))\n        self.play(Create(p1), Create(p2), Write(l1), Write(l2), GrowArrow(v1), GrowArrow(v2))\n        self.play(\n            p1.animate.move_to(ORIGIN + LEFT*0.3),\n            p2.animate.move_to(ORIGIN + RIGHT*0.3),\n            FadeOut(v1), FadeOut(v2), FadeOut(l1), FadeOut(l2),\n            run_time=1\n        )\n        flash = Circle(radius=0.5, color=YELLOW, fill_opacity=0.5).move_to(ORIGIN)\n        self.play(FadeIn(flash, scale=0.5), run_time=0.2)\n        self.play(FadeOut(flash), run_time=0.2)\n        self.play(\n            p1.animate.move_to(LEFT*3),\n            p2.animate.move_to(RIGHT*5),\n            run_time=1\n        )\n        self.wait()"}
{"prompt": "Show the concept of a hash table with key-value pairs", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Hash Table', font_size=42).to_edge(UP)\n        buckets = VGroup()\n        for i in range(6):\n            box = Rectangle(width=2, height=0.6, color=BLUE, fill_opacity=0.1)\n            box.shift(DOWN*(i*0.7 - 1.5))\n            idx = Text(str(i), font_size=20, color=GRAY).next_to(box, LEFT)\n            buckets.add(VGroup(box, idx))\n        self.play(Write(title), Create(buckets))\n        entries = [('name', 'Alice', 1), ('age', '25', 3), ('city', 'NYC', 0), ('job', 'Dev', 5)]\n        for key, val, bucket in entries:\n            entry = Text(f'{key}: {val}', font_size=18, color=YELLOW)\n            entry.move_to(buckets[bucket][0])\n            hash_text = Text(f'hash(\"{key}\") = {bucket}', font_size=16, color=GREEN).to_edge(RIGHT)\n            self.play(Write(hash_text), run_time=0.3)\n            self.play(Write(entry), buckets[bucket][0].animate.set_fill(GREEN, opacity=0.2), run_time=0.4)\n            self.play(FadeOut(hash_text), run_time=0.2)\n        self.wait()"}
{"prompt": "Create a visual comparison of different sorting algorithm complexities", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Sorting Algorithm Comparison', font_size=32).to_edge(UP)\n        table = Table(\n            [['O(n^2)', 'O(1)', 'Yes'],\n             ['O(n^2)', 'O(1)', 'No'],\n             ['O(n log n)', 'O(n)', 'Yes'],\n             ['O(n log n)', 'O(log n)', 'No']],\n            row_labels=[\n                Text('Bubble', font_size=20),\n                Text('Selection', font_size=20),\n                Text('Merge', font_size=20),\n                Text('Quick', font_size=20)\n            ],\n            col_labels=[\n                Text('Time', font_size=20),\n                Text('Space', font_size=20),\n                Text('Stable', font_size=20)\n            ]\n        ).scale(0.6)\n        self.play(Write(title))\n        self.play(Create(table), run_time=2)\n        self.wait()"}
{"prompt": "Animate the butterfly effect concept with diverging paths", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Butterfly Effect', font_size=42).to_edge(UP)\n        axes = Axes(x_range=[0, 8, 1], y_range=[-3, 3, 1])\n        np.random.seed(42)\n        path1_points = [[0, 0, 0]]\n        path2_points = [[0, 0.01, 0]]\n        for i in range(80):\n            x = (i+1) * 0.1\n            y1 = path1_points[-1][1] + 0.1*np.sin(path1_points[-1][1]*3 + x)\n            y2 = path2_points[-1][1] + 0.1*np.sin(path2_points[-1][1]*3 + x)\n            path1_points.append([x, y1, 0])\n            path2_points.append([x, y2, 0])\n        path1 = VMobject(color=BLUE, stroke_width=2)\n        path1.set_points_as_corners([axes.c2p(*p) for p in path1_points])\n        path2 = VMobject(color=RED, stroke_width=2)\n        path2.set_points_as_corners([axes.c2p(*p) for p in path2_points])\n        l1 = Text('x0 = 0.000', font_size=20, color=BLUE).to_corner(DL)\n        l2 = Text('x0 = 0.010', font_size=20, color=RED).next_to(l1, UP)\n        self.play(Write(title), Create(axes))\n        self.play(Create(path1), Create(path2), Write(l1), Write(l2), run_time=3)\n        self.wait()"}
{"prompt": "Show the normal distribution bell curve with standard deviations", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Normal Distribution', font_size=36).to_edge(UP)\n        axes = Axes(x_range=[-4, 4, 1], y_range=[0, 0.5, 0.1], x_length=10, y_length=5)\n        curve = axes.plot(lambda x: np.exp(-x**2/2)/np.sqrt(2*PI), color=BLUE)\n        area = axes.get_area(curve, x_range=[-1, 1], color=BLUE, opacity=0.3)\n        sd_labels = VGroup()\n        for i, label in enumerate(['-2s', '-1s', 'u', '+1s', '+2s']):\n            x = i - 2\n            tick = DashedLine(axes.c2p(x, 0), axes.c2p(x, 0.45), color=GRAY, stroke_width=1)\n            text = MathTex(label.replace('s', '\\\\sigma').replace('u', '\\\\mu'), font_size=22).next_to(tick, DOWN)\n            sd_labels.add(tick, text)\n        pct = Text('68%', font_size=24, color=BLUE).move_to(axes.c2p(0, 0.15))\n        self.play(Write(title), Create(axes))\n        self.play(Create(curve))\n        self.play(FadeIn(area), Create(sd_labels))\n        self.play(Write(pct))\n        self.wait()"}
{"prompt": "Create an animation showing bitwise AND operation", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Bitwise AND', font_size=42).to_edge(UP)\n        a_bits = '1 0 1 1'.split()\n        b_bits = '1 1 0 1'.split()\n        r_bits = '1 0 0 1'.split()\n        a_group = VGroup()\n        b_group = VGroup()\n        r_group = VGroup()\n        for i, (a, b, r) in enumerate(zip(a_bits, b_bits, r_bits)):\n            x = i*1.2 - 1.8\n            a_text = Text(a, font_size=36, color=BLUE).move_to([x, 1, 0])\n            b_text = Text(b, font_size=36, color=GREEN).move_to([x, 0, 0])\n            r_text = Text(r, font_size=36, color=YELLOW).move_to([x, -1.5, 0])\n            a_group.add(a_text)\n            b_group.add(b_text)\n            r_group.add(r_text)\n        a_label = Text('A = ', font_size=28, color=BLUE).next_to(a_group, LEFT)\n        b_label = Text('B = ', font_size=28, color=GREEN).next_to(b_group, LEFT)\n        r_label = Text('A&B= ', font_size=28, color=YELLOW).next_to(r_group, LEFT)\n        line = Line(LEFT*3, RIGHT*3, color=WHITE).shift(DOWN*0.7)\n        op = Text('AND', font_size=24).next_to(line, LEFT)\n        self.play(Write(title))\n        self.play(Write(a_label), Write(a_group))\n        self.play(Write(b_label), Write(b_group))\n        self.play(Create(line), Write(op))\n        self.play(Write(r_label), Write(r_group))\n        self.wait()"}
{"prompt": "Show the concept of recursion with Russian nesting dolls", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Recursion', font_size=42).to_edge(UP)\n        colors = [RED, ORANGE, YELLOW, GREEN, BLUE]\n        dolls = VGroup()\n        for i, color in enumerate(colors):\n            size = 2.5 - i*0.4\n            doll = Ellipse(width=size, height=size*1.3, color=color, fill_opacity=0.3)\n            dolls.add(doll)\n        self.play(Write(title))\n        for doll in dolls:\n            self.play(Create(doll), run_time=0.5)\n        label = Text('f(n) calls f(n-1) calls f(n-2) ...', font_size=24, color=GRAY).shift(DOWN*2.5)\n        self.play(Write(label))\n        self.wait()"}
{"prompt": "Animate text morphing through multiple words", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        words = ['Hello', 'Hola', 'Bonjour', 'Ciao', 'Hallo']\n        colors = [WHITE, YELLOW, BLUE, GREEN, RED]\n        current = Text(words[0], font_size=72, color=colors[0])\n        self.play(Write(current))\n        for word, color in zip(words[1:], colors[1:]):\n            new = Text(word, font_size=72, color=color)\n            self.play(TransformMatchingShapes(current, new), run_time=0.8)\n            current = new\n            self.wait(0.3)\n        self.wait()"}
{"prompt": "Create a simple neural network forward pass animation", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Neural Network Forward Pass', font_size=32).to_edge(UP)\n        layers = [3, 4, 4, 2]\n        neurons = []\n        for l, count in enumerate(layers):\n            layer = []\n            for n in range(count):\n                y = (n - (count-1)/2) * 1\n                neuron = Circle(radius=0.2, color=BLUE, fill_opacity=0.2).move_to([l*2.5 - 3.75, y, 0])\n                layer.append(neuron)\n            neurons.append(layer)\n        all_neurons = VGroup(*[n for layer in neurons for n in layer])\n        edges = VGroup()\n        for l in range(len(layers)-1):\n            for n1 in neurons[l]:\n                for n2 in neurons[l+1]:\n                    edges.add(Line(n1.get_center(), n2.get_center(), color=GRAY, stroke_width=0.5))\n        self.play(Write(title), Create(edges), Create(all_neurons))\n        for l in range(len(layers)):\n            highlights = [neurons[l][n].animate.set_fill(YELLOW, opacity=0.8) for n in range(layers[l])]\n            self.play(*highlights, run_time=0.5)\n            unhighlights = [neurons[l][n].animate.set_fill(BLUE, opacity=0.2) for n in range(layers[l])]\n            self.play(*unhighlights, run_time=0.3)\n        self.wait()"}
{"prompt": "Show Snell's law of refraction", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text(\"Snell's Law\", font_size=42).to_edge(UP)\n        interface = Line(LEFT*4, RIGHT*4, color=WHITE)\n        normal = DashedLine(UP*2.5, DOWN*2.5, color=GRAY)\n        incident = Arrow(LEFT*2.5 + UP*2.5, ORIGIN, color=RED, buff=0)\n        refracted = Arrow(ORIGIN, RIGHT*1.5 + DOWN*2.5, color=BLUE, buff=0)\n        theta1_arc = Angle(normal, Line(ORIGIN, LEFT*2.5 + UP*2.5), radius=0.8, color=RED, other_angle=True)\n        theta2_arc = Angle(Line(ORIGIN, RIGHT*1.5 + DOWN*2.5), DashedLine(ORIGIN, DOWN*2.5), radius=0.8, color=BLUE)\n        t1_label = MathTex('\\\\theta_1', font_size=28, color=RED).shift(LEFT*0.5 + UP*1.2)\n        t2_label = MathTex('\\\\theta_2', font_size=28, color=BLUE).shift(RIGHT*0.8 + DOWN*1.2)\n        medium1 = Text('Air (n=1)', font_size=22).shift(LEFT*3 + UP*1.5)\n        medium2 = Text('Glass (n=1.5)', font_size=22).shift(LEFT*3 + DOWN*1.5)\n        formula = MathTex('n_1 \\\\sin\\\\theta_1 = n_2 \\\\sin\\\\theta_2', font_size=36).shift(DOWN*3)\n        self.play(Write(title))\n        self.play(Create(interface), Create(normal), Write(medium1), Write(medium2))\n        self.play(GrowArrow(incident), Create(theta1_arc), Write(t1_label))\n        self.play(GrowArrow(refracted), Create(theta2_arc), Write(t2_label))\n        self.play(Write(formula))\n        self.wait()"}
{"prompt": "Create a memory diagram showing stack and heap", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Stack vs Heap Memory', font_size=36).to_edge(UP)\n        stack_box = Rectangle(width=3, height=5, color=BLUE, fill_opacity=0.05).shift(LEFT*3 + DOWN*0.3)\n        heap_box = Rectangle(width=3, height=5, color=RED, fill_opacity=0.05).shift(RIGHT*3 + DOWN*0.3)\n        stack_title = Text('Stack', font_size=28, color=BLUE).next_to(stack_box, UP)\n        heap_title = Text('Heap', font_size=28, color=RED).next_to(heap_box, UP)\n        stack_items = VGroup()\n        entries = [('int x = 5', GREEN), ('int y = 10', GREEN), ('ptr -> [obj]', YELLOW)]\n        for i, (text, color) in enumerate(entries):\n            item = Rectangle(width=2.5, height=0.6, color=color, fill_opacity=0.2)\n            item.move_to(stack_box.get_bottom() + UP*(0.5 + i*0.7))\n            label = Text(text, font_size=16).move_to(item)\n            stack_items.add(VGroup(item, label))\n        heap_items = VGroup()\n        obj = Rectangle(width=2.5, height=1.2, color=ORANGE, fill_opacity=0.2).move_to(heap_box.get_center() + UP*0.5)\n        obj_label = Text('{name: \"hi\"}', font_size=16).move_to(obj)\n        heap_items.add(VGroup(obj, obj_label))\n        arrow = Arrow(stack_items[-1].get_right() + RIGHT*0.2, obj.get_left(), buff=0.1, color=YELLOW)\n        self.play(Write(title))\n        self.play(Create(stack_box), Write(stack_title), Create(heap_box), Write(heap_title))\n        for item in stack_items:\n            self.play(Create(item), run_time=0.4)\n        self.play(Create(heap_items), GrowArrow(arrow))\n        self.wait()"}
{"prompt": "Show the concept of map, filter, reduce in functional programming", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Map, Filter, Reduce', font_size=36).to_edge(UP)\n        data = VGroup(*[Text(str(n), font_size=28).shift(RIGHT*(i*0.8 - 2)) for i, n in enumerate([1,2,3,4,5])])\n        data_label = Text('[1, 2, 3, 4, 5]', font_size=24).shift(UP*2)\n        map_label = Text('map(x*2)', font_size=22, color=BLUE).shift(UP*1)\n        mapped = VGroup(*[Text(str(n), font_size=28, color=BLUE).shift(RIGHT*(i*0.8 - 2)) for i, n in enumerate([2,4,6,8,10])])\n        filter_label = Text('filter(>4)', font_size=22, color=GREEN).shift(ORIGIN)\n        filtered = VGroup(*[Text(str(n), font_size=28, color=GREEN).shift(RIGHT*(i*0.8 - 0.8)) for i, n in enumerate([6,8,10])])\n        reduce_label = Text('reduce(+)', font_size=22, color=RED).shift(DOWN*1)\n        result = Text('= 24', font_size=36, color=RED).shift(DOWN*2)\n        self.play(Write(title), Write(data_label))\n        self.play(Write(map_label), TransformMatchingShapes(data, mapped))\n        mapped.shift(DOWN)\n        self.play(Write(filter_label), TransformMatchingShapes(mapped.copy(), filtered))\n        filtered.shift(DOWN*2)\n        self.play(Write(reduce_label), Write(result))\n        self.wait()"}
{"prompt": "Animate a catenary curve (hanging chain)", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        axes = Axes(x_range=[-3, 3, 1], y_range=[0, 6, 1])\n        catenary = axes.plot(lambda x: np.cosh(x), x_range=[-2.5, 2.5], color=BLUE)\n        title = Text('Catenary Curve', font_size=36).to_edge(UP)\n        formula = MathTex('y = \\\\cosh(x) = \\\\frac{e^x + e^{-x}}{2}', font_size=32).to_corner(DR)\n        support1 = Dot(axes.c2p(-2.5, np.cosh(-2.5)), color=RED, radius=0.1)\n        support2 = Dot(axes.c2p(2.5, np.cosh(2.5)), color=RED, radius=0.1)\n        self.play(Write(title), Create(axes))\n        self.play(Create(support1), Create(support2))\n        self.play(Create(catenary), run_time=2)\n        self.play(Write(formula))\n        self.wait()"}
{"prompt": "Create a visual showing TCP three-way handshake", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('TCP Three-Way Handshake', font_size=32).to_edge(UP)\n        client = Rectangle(width=2, height=1, color=BLUE, fill_opacity=0.2).shift(LEFT*4 + UP*0.5)\n        server = Rectangle(width=2, height=1, color=GREEN, fill_opacity=0.2).shift(RIGHT*4 + UP*0.5)\n        cl = Text('Client', font_size=22).move_to(client)\n        sl = Text('Server', font_size=22).move_to(server)\n        client_line = Line(LEFT*4 + DOWN*0.2, LEFT*4 + DOWN*3, color=BLUE)\n        server_line = Line(RIGHT*4 + DOWN*0.2, RIGHT*4 + DOWN*3, color=GREEN)\n        syn = Arrow(LEFT*4 + DOWN*0.5, RIGHT*4 + DOWN*1, color=RED, buff=0)\n        syn_label = Text('SYN', font_size=20, color=RED).next_to(syn, UP, buff=0.05)\n        syn_ack = Arrow(RIGHT*4 + DOWN*1.3, LEFT*4 + DOWN*1.8, color=YELLOW, buff=0)\n        sa_label = Text('SYN-ACK', font_size=20, color=YELLOW).next_to(syn_ack, UP, buff=0.05)\n        ack = Arrow(LEFT*4 + DOWN*2.1, RIGHT*4 + DOWN*2.6, color=GREEN, buff=0)\n        ack_label = Text('ACK', font_size=20, color=GREEN).next_to(ack, UP, buff=0.05)\n        self.play(Write(title))\n        self.play(Create(client), Write(cl), Create(server), Write(sl))\n        self.play(Create(client_line), Create(server_line))\n        self.play(GrowArrow(syn), Write(syn_label))\n        self.play(GrowArrow(syn_ack), Write(sa_label))\n        self.play(GrowArrow(ack), Write(ack_label))\n        connected = Text('Connected!', font_size=28, color=GREEN).shift(DOWN*3)\n        self.play(Write(connected))\n        self.wait()"}
{"prompt": "Show the concept of dot product visually", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Dot Product', font_size=42).to_edge(UP)\n        plane = NumberPlane(x_range=[-4, 4], y_range=[-3, 3])\n        v1 = Arrow(ORIGIN, [3, 1, 0], color=RED, buff=0)\n        v2 = Arrow(ORIGIN, [1, 2, 0], color=BLUE, buff=0)\n        l1 = MathTex('\\\\vec{a} = (3, 1)', font_size=28, color=RED).move_to([3.5, 1.5, 0])\n        l2 = MathTex('\\\\vec{b} = (1, 2)', font_size=28, color=BLUE).move_to([0.5, 2.5, 0])\n        angle_arc = Angle(v1, v2, radius=0.7, color=YELLOW)\n        theta = MathTex('\\\\theta', font_size=24, color=YELLOW).move_to([1, 0.7, 0])\n        formula = MathTex(\n            '\\\\vec{a} \\\\cdot \\\\vec{b} = 3(1) + 1(2) = 5',\n            font_size=32\n        ).shift(DOWN*2.5)\n        self.play(Write(title))\n        self.add(plane)\n        self.play(GrowArrow(v1), Write(l1))\n        self.play(GrowArrow(v2), Write(l2))\n        self.play(Create(angle_arc), Write(theta))\n        self.play(Write(formula))\n        self.wait()"}
{"prompt": "Create an animation of dominoes with numbers", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Domino Chain', font_size=36).to_edge(UP)\n        dominoes = VGroup()\n        for i in range(6):\n            box = Rectangle(width=0.8, height=1.4, color=WHITE, fill_opacity=0.1)\n            top_num = Text(str(i), font_size=22).move_to(box.get_center() + UP*0.3)\n            bottom_num = Text(str(i+1), font_size=22).move_to(box.get_center() + DOWN*0.3)\n            line = Line(box.get_left() + UP*0, box.get_right() + UP*0, color=GRAY, stroke_width=1)\n            domino = VGroup(box, top_num, bottom_num, line).shift(RIGHT*(i*1.1 - 2.75))\n            dominoes.add(domino)\n        self.play(Write(title))\n        self.play(LaggedStart(*[FadeIn(d, shift=DOWN) for d in dominoes], lag_ratio=0.15))\n        for d in dominoes:\n            self.play(Indicate(d), run_time=0.3)\n        self.wait()"}
{"prompt": "Show the difference between stack and queue with animations", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Stack (LIFO) vs Queue (FIFO)', font_size=32).to_edge(UP)\n        stack_label = Text('Stack', font_size=28, color=BLUE).shift(LEFT*3.5 + UP*2)\n        queue_label = Text('Queue', font_size=28, color=GREEN).shift(RIGHT*3.5 + UP*2)\n        stack_items = VGroup()\n        queue_items = VGroup()\n        colors = [RED, ORANGE, YELLOW]\n        self.play(Write(title), Write(stack_label), Write(queue_label))\n        for i, (val, color) in enumerate(zip([1, 2, 3], colors)):\n            s_item = Rectangle(width=2, height=0.5, fill_color=color, fill_opacity=0.6, color=WHITE)\n            s_item.move_to(LEFT*3.5 + UP*(0.5 - i*0.6))\n            s_text = Text(str(val), font_size=22).move_to(s_item)\n            stack_items.add(VGroup(s_item, s_text))\n            q_item = Rectangle(width=2, height=0.5, fill_color=color, fill_opacity=0.6, color=WHITE)\n            q_item.move_to(RIGHT*3.5 + UP*(0.5 - i*0.6))\n            q_text = Text(str(val), font_size=22).move_to(q_item)\n            queue_items.add(VGroup(q_item, q_text))\n            self.play(FadeIn(stack_items[-1]), FadeIn(queue_items[-1]), run_time=0.4)\n        pop_s = Text('Pop: 3 (last)', font_size=20, color=RED).shift(LEFT*3.5 + DOWN*2)\n        pop_q = Text('Dequeue: 1 (first)', font_size=20, color=RED).shift(RIGHT*3.5 + DOWN*2)\n        self.play(FadeOut(stack_items[-1], shift=UP), Write(pop_s))\n        self.play(FadeOut(queue_items[0], shift=RIGHT), Write(pop_q))\n        self.wait()"}
{"prompt": "Animate the Collatz conjecture for starting number 7", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Collatz Conjecture (n=7)', font_size=36).to_edge(UP)\n        sequence = [7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]\n        dots = VGroup()\n        lines = VGroup()\n        for i, val in enumerate(sequence):\n            x = (i % 9) * 1.2 - 4.8\n            y = 1 - (i // 9) * 2.5\n            dot = Dot([x, y, 0], color=BLUE if val % 2 == 0 else RED, radius=0.15)\n            label = Text(str(val), font_size=16).next_to(dot, UP, buff=0.1)\n            dots.add(VGroup(dot, label))\n            if i > 0:\n                prev_x = ((i-1) % 9) * 1.2 - 4.8\n                prev_y = 1 - ((i-1) // 9) * 2.5\n                line = Arrow([prev_x, prev_y, 0], [x, y, 0], buff=0.2, stroke_width=1.5, color=GRAY)\n                lines.add(line)\n        rule = Text('Even: n/2 | Odd: 3n+1', font_size=22, color=GRAY).shift(DOWN*3)\n        self.play(Write(title), Write(rule))\n        for i in range(len(sequence)):\n            anims = [Create(dots[i])]  \n            if i > 0:\n                anims.append(GrowArrow(lines[i-1]))\n            self.play(*anims, run_time=0.25)\n        self.wait()"}
{"prompt": "Create a simple physics free body diagram", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Free Body Diagram', font_size=36).to_edge(UP)\n        box = Square(side_length=1.5, color=WHITE, fill_opacity=0.2)\n        weight = Arrow(box.get_center(), box.get_center() + DOWN*2, color=RED, buff=0)\n        normal = Arrow(box.get_center(), box.get_center() + UP*2, color=BLUE, buff=0)\n        friction = Arrow(box.get_center(), box.get_center() + LEFT*1.5, color=GREEN, buff=0)\n        applied = Arrow(box.get_center(), box.get_center() + RIGHT*2.5, color=YELLOW, buff=0)\n        w_label = MathTex('\\\\vec{W}', font_size=28, color=RED).next_to(weight, RIGHT)\n        n_label = MathTex('\\\\vec{N}', font_size=28, color=BLUE).next_to(normal, RIGHT)\n        f_label = MathTex('\\\\vec{f}', font_size=28, color=GREEN).next_to(friction, UP)\n        a_label = MathTex('\\\\vec{F}', font_size=28, color=YELLOW).next_to(applied, UP)\n        self.play(Write(title))\n        self.play(Create(box))\n        self.play(GrowArrow(weight), Write(w_label))\n        self.play(GrowArrow(normal), Write(n_label))\n        self.play(GrowArrow(friction), Write(f_label))\n        self.play(GrowArrow(applied), Write(a_label))\n        eq = MathTex('\\\\sum \\\\vec{F} = m\\\\vec{a}', font_size=36).shift(DOWN*3)\n        self.play(Write(eq))\n        self.wait()"}
{"prompt": "Show the RGB color model as a Venn diagram", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('RGB Color Model', font_size=42).to_edge(UP)\n        r = Circle(radius=1.5, color=RED, fill_opacity=0.4).shift(LEFT*0.8 + UP*0.5)\n        g = Circle(radius=1.5, color=GREEN, fill_opacity=0.4).shift(RIGHT*0.8 + UP*0.5)\n        b = Circle(radius=1.5, color=BLUE, fill_opacity=0.4).shift(DOWN*0.5)\n        rl = Text('Red', font_size=22, color=RED).move_to(LEFT*2.3 + UP*1.5)\n        gl = Text('Green', font_size=22, color=GREEN).move_to(RIGHT*2.3 + UP*1.5)\n        bl = Text('Blue', font_size=22, color=BLUE).move_to(DOWN*2.2)\n        yl = Text('Yellow', font_size=16).move_to(UP*1.2)\n        cl = Text('Cyan', font_size=16).move_to(RIGHT*0.8 + DOWN*0.3)\n        ml = Text('Magenta', font_size=16).move_to(LEFT*0.8 + DOWN*0.3)\n        wl = Text('White', font_size=16).move_to(UP*0.2)\n        self.play(Write(title))\n        self.play(Create(r), Create(g), Create(b))\n        self.play(Write(rl), Write(gl), Write(bl))\n        self.play(Write(yl), Write(cl), Write(ml), Write(wl))\n        self.wait()"}
{"prompt": "Animate a loading bar with percentage", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Loading...', font_size=36).shift(UP*2)\n        bg = RoundedRectangle(width=8, height=0.8, corner_radius=0.15, color=GRAY, fill_opacity=0.2)\n        fill = RoundedRectangle(width=0.01, height=0.7, corner_radius=0.1, color=GREEN, fill_opacity=0.8)\n        fill.align_to(bg, LEFT).shift(RIGHT*0.05)\n        pct = DecimalNumber(0, num_decimal_places=0, font_size=36, unit='%').shift(DOWN*1.5)\n        self.play(Write(title), Create(bg))\n        self.add(fill, pct)\n        self.play(\n            fill.animate.stretch_to_fit_width(7.9).align_to(bg, LEFT).shift(RIGHT*0.05),\n            ChangeDecimalToValue(pct, 100),\n            run_time=3\n        )\n        done = Text('Complete!', font_size=36, color=GREEN).shift(UP*2)\n        self.play(Transform(title, done))\n        self.wait()"}
{"prompt": "Show the Fibonacci spiral on a grid", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Fibonacci Spiral', font_size=36).to_edge(UP)\n        fibs = [1, 1, 2, 3, 5, 8]\n        scale = 0.3\n        rects = VGroup()\n        arcs = VGroup()\n        positions = [(0,0), (1,0), (0,1), (-2,0), (0,-3), (3,-3)]\n        angles = [0, PI/2, PI, 3*PI/2, 0, PI/2]\n        for i, (f, (px, py), angle) in enumerate(zip(fibs, positions, angles)):\n            rect = Rectangle(width=f*scale, height=f*scale, color=BLUE, fill_opacity=0.1)\n            rect.move_to([px*scale + f*scale/2, py*scale + f*scale/2, 0])\n            rects.add(rect)\n            arc = Arc(radius=f*scale, start_angle=angle, angle=PI/2, color=GOLD)\n            arc.move_to(rect.get_center())\n            arcs.add(arc)\n        group = VGroup(rects, arcs).move_to(ORIGIN).scale(1.5)\n        self.play(Write(title))\n        for r, a in zip(rects, arcs):\n            self.play(Create(r), Create(a), run_time=0.5)\n        self.wait()"}
{"prompt": "Create a simple calculator display animation", "code": "from manim import *\n\nclass GenScene(Scene):\n    def construct(self):\n        screen = Rectangle(width=5, height=1.2, color=DARK_GRAY, fill_opacity=0.8).shift(UP*2)\n        body = Rectangle(width=5.5, height=5, color=GRAY, fill_opacity=0.3).shift(DOWN*0.5)\n        display = Text('0', font_size=48, color=GREEN).move_to(screen)\n        buttons = VGroup()\n        labels = ['7','8','9','+','4','5','6','-','1','2','3','*','C','0','=','/']\n        for i, label in enumerate(labels):\n            row, col = i // 4, i % 4\n            btn = Rectangle(width=1, height=0.8, color=BLUE if label.isdigit() else ORANGE, fill_opacity=0.3)\n            btn.move_to(RIGHT*(col*1.2 - 1.8) + DOWN*(row*1 - 0.8))\n            txt = Text(label, font_size=22).move_to(btn)\n            buttons.add(VGroup(btn, txt))\n        self.play(Create(body), Create(screen), Write(display))\n        self.play(Create(buttons))\n        calcs = [('2', '2'), ('+', '2+'), ('3', '2+3'), ('=', '5')]\n        for key, shown in calcs:\n            new_display = Text(shown, font_size=48, color=GREEN).move_to(screen)\n            self.play(Transform(display, new_display), run_time=0.4)\n        self.wait()"}
{"prompt": "Animate a simple harmonic motion with position vs time graph", "code": "from manim import *\nimport numpy as np\n\nclass GenScene(Scene):\n    def construct(self):\n        title = Text('Simple Harmonic Motion', font_size=32).to_edge(UP)\n        axes = Axes(x_range=[0, 8, 1], y_range=[-2, 2, 1], x_length=7, y_length=3).shift(DOWN*1)\n        x_label = Text('Time', font_size=20).next_to(axes.x_axis, DOWN)\n        y_label = Text('Position', font_size=20).next_to(axes.y_axis, LEFT).rotate(PI/2)\n        t = ValueTracker(0)\n        curve = always_redraw(lambda: axes.plot(\n            lambda x: 1.5*np.sin(2*x),\n            x_range=[0, min(t.get_value(), 8)],\n            color=BLUE\n        ))\n        dot = always_redraw(lambda: Dot(\n            [t.get_value()*7/8 - 3.5 + axes.get_center()[0], 1.5*np.sin(2*t.get_value())*3/4 + axes.get_center()[1], 0],\n            color=RED\n        ) if t.get_value() > 0 else Dot(axes.c2p(0, 0), color=RED))\n        spring_bob = always_redraw(lambda: Dot(\n            [-5, 1.5*np.sin(2*t.get_value()), 0],\n            color=RED, radius=0.2\n        ))\n        eq_line = DashedLine([-5.5, 0, 0], [-4.5, 0, 0], color=GRAY)\n        self.play(Write(title), Create(axes), Write(x_label), Write(y_label))\n        self.add(curve, spring_bob, eq_line)\n        self.play(t.animate.set_value(8), run_time=5, rate_func=linear)\n        self.wait()"}
